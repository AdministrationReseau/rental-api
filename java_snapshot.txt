This is the structure and content of a Java Maven project. My goal is to [...Describe your objective here...]. Please analyze the code for inconsistencies, suggest improvements, and complete any missing parts.

## Project Structure

```
    |-- .gitattributes
    |-- .gitignore
    |-- Dockerfile
    |-- LICENSE.txt
    |-- README.md
    |-- docker-compose.yml
    |-- mvnw
    |-- mvnw.cmd
    |-- pom.xml
|-- .mvn/
    |-- wrapper/
        |-- maven-wrapper.properties
|-- src/
    |-- main/
        |-- java/
            |-- inc/
                |-- yowyob/
                    |-- rental_api/
                        |-- RentalApiApplication.java
                        |-- chat/
                            |-- readme.md
                        |-- common/
                            |-- exception/
                                |-- readme.md
                            |-- response/
                                |-- ApiResponse.java
                                |-- ApiResponseUtil.java
                            |-- validation/
                                |-- readme.md
                        |-- config/
                            |-- AppProperties.java
                            |-- OpenApiConfig.java
                            |-- WebConfig.java
                        |-- core/
                            |-- dto/
                                |-- readme.md
                            |-- entities/
                                |-- readme.md
                            |-- enums/
                                |-- BillingInterval.java
                                |-- OnboardingStatus.java
                                |-- OnboardingStep.java
                                |-- OrganizationType.java
                                |-- Permission.java
                                |-- RoleType.java
                                |-- SubscriptionFeature.java
                                |-- SubscriptionPlanType.java
                                |-- SubscriptionStatus.java
                                |-- UserStatus.java
                                |-- UserType.java
                        |-- driver/
                            |-- readme.md
                        |-- geofence/
                            |-- readme.md
                        |-- notification/
                            |-- readme.md
                        |-- onboarding/
                            |-- controller/
                                |-- OnboardingController.java
                            |-- dto/
                                |-- CompleteOnboardingDto.java
                                |-- CreateOnboardingSessionDto.java
                                |-- OnboardingCompletedDto.java
                                |-- OnboardingSessionDto.java
                                |-- OnboardingStatsDto.java
                                |-- OrganizationInfoDto.java
                                |-- OrganizationPolicyDto.java
                                |-- OwnerInfoDto.java
                                |-- SubscriptionInfoDto.java
                            |-- entities/
                                |-- OnboardingSession.java
                            |-- repository/
                                |-- OnboardingSessionRepository.java
                            |-- service/
                                |-- OnboardingService.java
                        |-- organization/
                            |-- readme.md
                        |-- payment/
                            |-- readme.md
                        |-- rental/
                            |-- readme.md
                        |-- role/
                            |-- config/
                                |-- RoleDataInitializer.java
                                |-- RolePermissionConfig.java
                            |-- controller/
                                |-- RoleController.java
                            |-- dto/
                                |-- AssignRoleDto.java
                                |-- BulkAssignRoleDto.java
                                |-- CreateRoleDto.java
                                |-- PermissionDto.java
                                |-- PermissionGroupDto.java
                                |-- RoleDto.java
                                |-- RolePermissionsDto.java
                                |-- RoleStatsDto.java
                                |-- RoleTemplateDto.java
                                |-- UpdateRoleDto.java
                                |-- UserPermissionsDto.java
                                |-- UserRoleDto.java
                            |-- entities/
                                |-- Role.java
                                |-- UserRole.java
                            |-- repository/
                                |-- RoleRepository.java
                                |-- UserRoleRepository.java
                            |-- service/
                                |-- RoleService.java
                        |-- security/
                            |-- annotations/
                                |-- RequireAgencyAccess.java
                                |-- RequireAllPermissions.java
                                |-- RequireAnyPermission.java
                                |-- RequireOrganizationAccess.java
                                |-- RequirePermission.java
                                |-- RequireRole.java
                            |-- aspect/
                                |-- PermissionAspect.java
                            |-- config/
                                |-- SecurityConfig.java
                            |-- jwt/
                                |-- JwtAuthenticationFilter.java
                                |-- JwtTokenProvider.java
                            |-- model/
                                |-- UserPrincipal.java
                            |-- service/
                                |-- CustomUserDetailsService.java
                                |-- PermissionEvaluationService.java
                            |-- util/
                                |-- SecurityUtils.java
                        |-- subscription/
                            |-- config/
                                |-- SubscriptionDataInitializer.java
                            |-- controller/
                                |-- SubscriptionController.java
                            |-- entities/
                                |-- OrganizationSubscription.java
                                |-- SubscriptionPlan.java
                            |-- repository/
                                |-- OrganizationSubscriptionRepository.java
                                |-- SubscriptionPlanRepository.java
                            |-- service/
                                |-- SubscriptionService.java
                        |-- user/
                            |-- config/
                                |-- UserDataInitializer.java
                            |-- controller/
                                |-- AuthController.java
                            |-- dto/
                                |-- AuthResponseDto.java
                                |-- ChangePasswordRequestDto.java
                                |-- LoginRequestDto.java
                                |-- RefreshTokenRequestDto.java
                                |-- RegisterRequestDto.java
                            |-- entities/
                                |-- User.java
                            |-- repository/
                                |-- UserRepository.java
                            |-- service/
                                |-- AuthService.java
                        |-- vehicle/
                            |-- readme.md
        |-- resources/
            |-- application.properties
    |-- test/
        |-- java/
            |-- inc/
                |-- yowyob/
                    |-- rental_api/
                        |-- RentalApiApplicationTests.java
```

## File Contents

--- PATH: .gitattributes ---

```
/mvnw text eol=lf
*.cmd text eol=crlf
```

--- PATH: .gitignore ---

```
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
```

--- PATH: Dockerfile ---

```
# Dockerfile pour Rental API
# Build stage
FROM maven:3.9.6-eclipse-temurin-21-alpine AS build

# Définir le répertoire de travail
WORKDIR /app

# Copier les fichiers Maven pour la résolution des dépendances
COPY pom.xml .
COPY .mvn .mvn
COPY mvnw .
COPY mvnw.cmd .

# Rendre mvnw exécutable
RUN chmod +x mvnw

# Télécharger les dépendances (mise en cache des layers)
RUN ./mvnw dependency:go-offline -B

# Copier le code source
COPY src src

# Construire l'application (skip tests pour build plus rapide)
RUN ./mvnw clean package -DskipTests

# Runtime stage
FROM eclipse-temurin:21-jre-alpine

# Installer curl pour health checks
RUN apk add --no-cache curl

# Créer un utilisateur non-root pour la sécurité
RUN addgroup -g 1001 -S rental && \
    adduser -u 1001 -S rental -G rental

# Définir le répertoire de travail
WORKDIR /app

# Copier le JAR depuis le stage de build
COPY --from=build /app/target/rental-api-*.jar app.jar

# Créer le répertoire des uploads
RUN mkdir -p /app/uploads && \
    chown -R rental:rental /app

# Changer vers l'utilisateur non-root
USER rental

# Exposer le port
EXPOSE 8080

# Variables d'environnement par défaut
ENV JAVA_OPTS="-Xms512m -Xmx1024m" \
    SPRING_PROFILES_ACTIVE=prod \
    TZ=Africa/Douala

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/api/v1/actuator/health || exit 1

# Point d'entrée
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

--- PATH: LICENSE.txt ---

```
MIT License

Copyright (c) 2025 AdministrationReseau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

--- PATH: README.md ---

```markdown

```

--- PATH: docker-compose.yml ---

```yaml
version: '3.8'

services:
    scylla:
        image: scylladb/scylla
        container_name: some-scylla
        ports:
            - "9042:9042"
        networks:
            - scylla-net

    rental-api:
        build: .
        container_name: rental-api
        ports:
            - "8080:8080"
        depends_on:
            - scylla
        networks:
            - scylla-net
        environment:
            - server.servlet.context-path=/api/v1
            - server.error.include-message=always
            - server.error.include-binding-errors=always

            # config cassandra
            - SPRING_CASSANDRA_CONTACT_POINTS=scylla
            - SPRING_CASSANDRA_KEYSPACE_NAME=rental
            - SPRING_CASSANDRA_USERNAME=cassandra
            - SPRING_CASSANDRA_PASSWORD=cassandra
            - SPRING_CASSANDRA_PORT=9045
            - SPRING_CASSANDRA_LOCAL_DATACENTER=datacenter1
            - spring.cassandra.schema-action=CREATE_IF_NOT_EXISTS
            - spring.cassandra.request.timeout=10s
            - spring.cassandra.connection.connect-timeout=10s
            - spring.cassandra.connection.init-query-timeout=10s

            # config cors
            - app.cors.allowed-origins=http://localhost:3000,http://localhost:8080,http://localhost:4200
            - app.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,PATCH
            - app.cors.allowed-headers=*
            - app.cors.allow-credentials=true

            #config jwt
            - app.jwt.secret=KsBman55FbHOoyT2SCZl46RZnc0oySFlenms644lQPKOt//JW78D5brRZuWelLzVts/ACnJcdXtIEl3D57KO5w==
            - app.jwt.expiration=86400000
            - app.jwt.refresh-expiration=604800000

            # config swagger
            - springdoc.api-docs.enabled=true
            - springdoc.api-docs.path=/v3/api-docs
            - springdoc.swagger-ui.enabled=true
            - springdoc.swagger-ui.path=/swagger-ui.html
            - springdoc.swagger-ui.operations-sorter=method
            - springdoc.swagger-ui.tags-sorter=alpha
            - springdoc.swagger-ui.display-request-duration=true
            - springdoc.swagger-ui.show-extensions=true
            - springdoc.swagger-ui.show-common-extensions=true

            # config file
            - spring.servlet.multipart.enabled=true
            - spring.servlet.multipart.max-file-size=10MB
            - spring.servlet.multipart.max-request-size=10MB
            - app.file.upload-dir=./uploads
            - app.file.max-file-size=10485760
            - app.file.allowed-extensions=jpg,jpeg,png,pdf,doc,docx

networks:
    scylla-net:
        driver: bridge
```

--- PATH: mvnw ---

```
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
```

--- PATH: mvnw.cmd ---

```
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
```

--- PATH: pom.xml ---

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.5.0</version>
		<relativePath/>
	</parent>
	<groupId>inc.yowyob</groupId>
	<artifactId>rental-api</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>rental-api</name>
	<description>api pour le projet de location de vehicules</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>21</java.version>
	</properties>
	<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-cassandra</artifactId>
        </dependency>

        <dependency>
            <groupId>org.apache.cassandra</groupId>
            <artifactId>java-driver-core</artifactId>
            <version>4.18.1</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.30</version> <!-- ou une version stable récente -->
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.5.0</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>1.5.3.Final</version>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
        </dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>cassandra</artifactId>
            <scope>test</scope>
        </dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>21</source>
                    <target>21</target>
                    <annotationProcessorPaths>
                    <path>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                        <version>1.18.30</version>
                    </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
		</plugins>
	</build>

</project>
```

--- PATH: .mvn\wrapper\maven-wrapper.properties ---

```properties
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip
```

--- PATH: src\main\java\inc\yowyob\rental_api\RentalApiApplication.java ---

```java
package inc.yowyob.rental_api;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.cassandra.repository.config.EnableCassandraRepositories;

@SpringBootApplication
public class RentalApiApplication {

	public static void main(String[] args) {
		SpringApplication.run(RentalApiApplication.class, args);
	}
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\chat\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\common\exception\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\common\response\ApiResponse.java ---

```java
package inc.yowyob.rental_api.common.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * Classe de réponse API standardisée
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ApiResponse<T> {

    private boolean success;
    private String message;
    private T data;
    private Object metadata;
    private int statusCode;
    private LocalDateTime timestamp;
    private String path;

    // Constructeurs de convenance
    public static <T> ApiResponse<T> success(T data, String message) {
        return ApiResponse.<T>builder()
            .success(true)
            .message(message)
            .data(data)
            .statusCode(200)
            .timestamp(LocalDateTime.now())
            .build();
    }

    public static <T> ApiResponse<T> success(T data, String message, Object metadata) {
        return ApiResponse.<T>builder()
            .success(true)
            .message(message)
            .data(data)
            .metadata(metadata)
            .statusCode(200)
            .timestamp(LocalDateTime.now())
            .build();
    }

    public static <T> ApiResponse<T> error(String message, int statusCode) {
        return ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .statusCode(statusCode)
            .timestamp(LocalDateTime.now())
            .build();
    }

    public static <T> ApiResponse<T> error(String message, int statusCode, String path) {
        return ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .statusCode(statusCode)
            .path(path)
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\common\response\ApiResponseUtil.java ---

```java
package inc.yowyob.rental_api.common.response;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

/**
 * Utilitaire pour créer des réponses API standardisées
 */
public class ApiResponseUtil {

    /**
     * Crée une réponse de succès (200)
     */
    public static <T> ResponseEntity<ApiResponse<T>> success(T data, String message) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(true)
            .message(message)
            .data(data)
            .statusCode(200)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.ok(response);
    }

    /**
     * Crée une réponse de succès avec métadonnées (200)
     */
    public static <T> ResponseEntity<ApiResponse<T>> success(T data, String message, Object metadata) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(true)
            .message(message)
            .data(data)
            .metadata(metadata)
            .statusCode(200)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.ok(response);
    }

    /**
     * Crée une réponse de création (201)
     */
    public static <T> ResponseEntity<ApiResponse<T>> created(T data, String message) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(true)
            .message(message)
            .data(data)
            .statusCode(201)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * Crée une réponse de création avec métadonnées (201)
     */
    public static <T> ResponseEntity<ApiResponse<T>> created(T data, String message, Object metadata) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(true)
            .message(message)
            .data(data)
            .metadata(metadata)
            .statusCode(201)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * Crée une réponse de succès sans contenu (204)
     */
    public static ResponseEntity<Void> noContent() {
        return ResponseEntity.noContent().build();
    }

    /**
     * Crée une réponse de requête incorrecte (400)
     */
    public static <T> ResponseEntity<ApiResponse<T>> badRequest(String message) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .statusCode(400)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.badRequest().body(response);
    }

    /**
     * Crée une réponse non autorisé (401)
     */
    public static <T> ResponseEntity<ApiResponse<T>> unauthorized(String message) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .statusCode(401)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
    }

    /**
     * Crée une réponse interdit (403)
     */
    public static <T> ResponseEntity<ApiResponse<T>> forbidden(String message) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .statusCode(403)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
    }

    /**
     * Crée une réponse non trouvé (404)
     */
    public static <T> ResponseEntity<ApiResponse<T>> notFound(String message) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .statusCode(404)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }

    /**
     * Crée une réponse de conflit (409)
     */
    public static <T> ResponseEntity<ApiResponse<T>> conflict(String message) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .statusCode(409)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.status(HttpStatus.CONFLICT).body(response);
    }

    /**
     * Crée une réponse d'erreur interne (500)
     */
    public static <T> ResponseEntity<ApiResponse<T>> error(String message, int statusCode) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .statusCode(statusCode)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.status(statusCode).body(response);
    }

    /**
     * Crée une réponse d'erreur interne avec chemin (500)
     */
    public static <T> ResponseEntity<ApiResponse<T>> error(String message, int statusCode, String path) {
        ApiResponse<T> response = ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .statusCode(statusCode)
            .path(path)
            .timestamp(java.time.LocalDateTime.now())
            .build();

        return ResponseEntity.status(statusCode).body(response);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\common\validation\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\config\AppProperties.java ---

```java
package inc.yowyob.rental_api.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Data
@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {

    private Jwt jwt = new Jwt();
    private Cors cors = new Cors();
    private Subscription subscription = new Subscription();
    private File file = new File();

    @Data
    public static class Jwt {
        private String secret;
        private long expiration;
        private long refreshExpiration;
    }

    @Data
    public static class Cors {
        private String[] allowedOrigins;
        private String allowedMethods;
        private String allowedHeaders;
        private boolean allowCredentials;
    }

    @Data
    public static class Subscription {
        private int trialDurationDays;
    }

    @Data
    public static class File {
        private String uploadDir;
        private String maxFileSize;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\config\OpenApiConfig.java ---

```java
package inc.yowyob.rental_api.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.servers.Server;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class OpenApiConfig {

    @Value("${server.servlet.context-path:/}")
    private String contextPath;

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .servers(List.of(
                new Server()
                    .url("http://localhost:8080" + contextPath)
                    .description("Development Server"),
                new Server()
                    .url("https://api.rental.com" + contextPath)
                    .description("Production Server")
            ))
            .info(new Info()
                .title("Vehicle Rental API")
                .description("""
                            API complète pour la gestion de location de véhicules multi-agent.

                            ## Fonctionnalités principales :
                            - Gestion multi-tenant des organisations
                            - Système de forfaits d'abonnement
                            - Processus d'onboarding en 3 étapes
                            - Gestion des véhicules et chauffeurs
                            - Système de réservation intelligent
                            - Intégration paiements multiples
                            - Géofencing temps réel
                            - Chat intégré

                            ## Authentification :
                            1. **S'inscrire** : `POST /auth/register`
                            2. **Se connecter** : `POST /auth/login`
                            3. **Utiliser le token** : Authorization: Bearer <token>
                            4. **Rafraîchir** : `POST /auth/refresh`

                            ## Sécurité :
                            - Mots de passe : minimum 8 caractères, majuscule, minuscule, chiffre
                            - Compte verrouillé après 5 tentatives échouées (1 heure)
                            - Tokens JWT sécurisés avec signature HMAC256
                            """)
                .version("1.0.0")
                .contact(new Contact()
                    .name("Équipe Développement")
                    .email("dev@rentalapi.com")
                    .url("https://github.com/your-repo"))
                .license(new License()
                    .name("MIT License")
                    .url("https://opensource.org/licenses/MIT")))
            .addSecurityItem(new SecurityRequirement()
                .addList("Bearer Authentication"))
            .components(new Components()
                .addSecuritySchemes("Bearer Authentication",
                    new SecurityScheme()
                        .type(SecurityScheme.Type.HTTP)
                        .scheme("bearer")
                        .bearerFormat("JWT")
                        .description("Entrez votre token JWT")
                        .name("Authorization")
                        .in(SecurityScheme.In.HEADER)));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\config\WebConfig.java ---

```java
package inc.yowyob.rental_api.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Value("${app.cors.allowed-origins}")
    private String[] allowedOrigins;

    @Value("${app.cors.allowed-methods}")
    private String allowedMethods;

    @Value("${app.cors.allowed-headers}")
    private String allowedHeaders;

    @Value("${app.cors.allow-credentials}")
    private boolean allowCredentials;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins(allowedOrigins)
            .allowedMethods(allowedMethods.split(","))
            .allowedHeaders(allowedHeaders.split(","))
            .allowCredentials(allowCredentials)
            .maxAge(3600);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\dto\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\core\entities\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\BillingInterval.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

@Getter
public enum BillingInterval {
    MONTHLY("monthly", "Mensuel", 30),
    QUARTERLY("quarterly", "Trimestriel", 90),
    YEARLY("yearly", "Annuel", 365);

    private final String code;
    private final String description;
    private final int days;

    BillingInterval(String code, String description, int days) {
        this.code = code;
        this.description = description;
        this.days = days;
    }

    public String getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }

    public int getDays() {
        return days;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\OnboardingStatus.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

/**
 * Énumération des statuts du processus d'onboarding
 */
@Getter
public enum OnboardingStatus {
    IN_PROGRESS("in_progress", "En cours"),
    COMPLETED("completed", "Terminé"),
    EXPIRED("expired", "Expiré"),
    CANCELLED("cancelled", "Annulé"),
    FAILED("failed", "Échoué");

    private final String code;
    private final String description;

    OnboardingStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }

    public boolean isActive() {
        return this == IN_PROGRESS;
    }

    public boolean isFinished() {
        return this == COMPLETED || this == EXPIRED || this == CANCELLED || this == FAILED;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\OnboardingStep.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

/**
 * Énumération des étapes du processus d'onboarding
 */
@Getter
public enum OnboardingStep {
    OWNER_INFO("owner_info", "Informations du propriétaire", 1),
    ORGANIZATION_INFO("organization_info", "Informations de l'organisation", 2),
    SUBSCRIPTION_PAYMENT("subscription_payment", "Sélection forfait et paiement", 3);

    private final String code;
    private final String description;
    private final int order;

    OnboardingStep(String code, String description, int order) {
        this.code = code;
        this.description = description;
        this.order = order;
    }

    public boolean isAfter(OnboardingStep other) {
        return this.order > other.order;
    }

    public boolean isBefore(OnboardingStep other) {
        return this.order < other.order;
    }

    public OnboardingStep getNext() {
        OnboardingStep[] steps = OnboardingStep.values();
        int currentIndex = this.ordinal();
        if (currentIndex < steps.length - 1) {
            return steps[currentIndex + 1];
        }
        return this;
    }

    public OnboardingStep getPrevious() {
        OnboardingStep[] steps = OnboardingStep.values();
        int currentIndex = this.ordinal();
        if (currentIndex > 0) {
            return steps[currentIndex - 1];
        }
        return this;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\OrganizationType.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

/**
 * Énumération des types d'organisation
 */
@Getter
public enum OrganizationType {
    INDIVIDUAL("individual", "Particulier"),
    SMALL_BUSINESS("small_business", "Petite entreprise"),
    MEDIUM_BUSINESS("medium_business", "Moyenne entreprise"),
    LARGE_ENTERPRISE("large_enterprise", "Grande entreprise"),
    GOVERNMENT("government", "Organisme gouvernemental"),
    NON_PROFIT("non_profit", "Organisation à but non lucratif");

    private final String code;
    private final String description;

    OrganizationType(String code, String description) {
        this.code = code;
        this.description = description;
    }

    public String getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\Permission.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

/**
 * Énumération des permissions granulaires du système
 */
@Getter
public enum Permission {
    // === PERMISSIONS VÉHICULES ===
    VEHICLE_READ("vehicle_read", "Lire les informations des véhicules", "VEHICLE"),
    VEHICLE_WRITE("vehicle_write", "Créer de nouveaux véhicules", "VEHICLE"),
    VEHICLE_UPDATE("vehicle_update", "Modifier les véhicules existants", "VEHICLE"),
    VEHICLE_DELETE("vehicle_delete", "Supprimer des véhicules", "VEHICLE"),
    VEHICLE_MANAGE_IMAGES("vehicle_manage_images", "Gérer les images des véhicules", "VEHICLE"),
    VEHICLE_CHANGE_STATUS("vehicle_change_status", "Changer le statut des véhicules", "VEHICLE"),

    // === PERMISSIONS CHAUFFEURS ===
    DRIVER_READ("driver_read", "Lire les informations des chauffeurs", "DRIVER"),
    DRIVER_WRITE("driver_write", "Créer de nouveaux chauffeurs", "DRIVER"),
    DRIVER_UPDATE("driver_update", "Modifier les chauffeurs existants", "DRIVER"),
    DRIVER_DELETE("driver_delete", "Supprimer des chauffeurs", "DRIVER"),
    DRIVER_MANAGE_DOCUMENTS("driver_manage_documents", "Gérer les documents des chauffeurs", "DRIVER"),
    DRIVER_MANAGE_SCHEDULE("driver_manage_schedule", "Gérer les plannings des chauffeurs", "DRIVER"),

    // === PERMISSIONS LOCATIONS ===
    RENTAL_READ("rental_read", "Lire les informations des locations", "RENTAL"),
    RENTAL_WRITE("rental_write", "Créer de nouvelles locations", "RENTAL"),
    RENTAL_UPDATE("rental_update", "Modifier les locations existantes", "RENTAL"),
    RENTAL_DELETE("rental_delete", "Supprimer des locations", "RENTAL"),
    RENTAL_APPROVE("rental_approve", "Approuver les demandes de location", "RENTAL"),
    RENTAL_CANCEL("rental_cancel", "Annuler des locations", "RENTAL"),
    RENTAL_EXTEND("rental_extend", "Prolonger des locations", "RENTAL"),

    // === PERMISSIONS UTILISATEURS ===
    USER_READ("user_read", "Lire les informations des utilisateurs", "USER"),
    USER_WRITE("user_write", "Créer de nouveaux utilisateurs", "USER"),
    USER_UPDATE("user_update", "Modifier les utilisateurs existants", "USER"),
    USER_DELETE("user_delete", "Supprimer des utilisateurs", "USER"),
    USER_MANAGE_ROLES("user_manage_roles", "Gérer les rôles des utilisateurs", "USER"),
    USER_RESET_PASSWORD("user_reset_password", "Réinitialiser les mots de passe", "USER"),

    // === PERMISSIONS AGENCES ===
    AGENCY_READ("agency_read", "Lire les informations des agences", "AGENCY"),
    AGENCY_WRITE("agency_write", "Créer de nouvelles agences", "AGENCY"),
    AGENCY_UPDATE("agency_update", "Modifier les agences existantes", "AGENCY"),
    AGENCY_DELETE("agency_delete", "Supprimer des agences", "AGENCY"),
    AGENCY_MANAGE_STAFF("agency_manage_staff", "Gérer le personnel des agences", "AGENCY"),

    // === PERMISSIONS ORGANISATIONS ===
    ORGANIZATION_READ("organization_read", "Lire les informations de l'organisation", "ORGANIZATION"),
    ORGANIZATION_UPDATE("organization_update", "Modifier les informations de l'organisation", "ORGANIZATION"),
    ORGANIZATION_MANAGE_SETTINGS("organization_manage_settings", "Gérer les paramètres de l'organisation", "ORGANIZATION"),
    ORGANIZATION_MANAGE_SUBSCRIPTION("organization_manage_subscription", "Gérer l'abonnement de l'organisation", "ORGANIZATION"),

    // === PERMISSIONS RÔLES ===
    ROLE_READ("role_read", "Lire les informations des rôles", "ROLE"),
    ROLE_WRITE("role_write", "Créer de nouveaux rôles", "ROLE"),
    ROLE_UPDATE("role_update", "Modifier les rôles existants", "ROLE"),
    ROLE_DELETE("role_delete", "Supprimer des rôles", "ROLE"),
    ROLE_ASSIGN_PERMISSIONS("role_assign_permissions", "Assigner des permissions aux rôles", "ROLE"),

    // === PERMISSIONS PAIEMENTS ===
    PAYMENT_READ("payment_read", "Lire les informations des paiements", "PAYMENT"),
    PAYMENT_PROCESS("payment_process", "Traiter les paiements", "PAYMENT"),
    PAYMENT_REFUND("payment_refund", "Effectuer des remboursements", "PAYMENT"),
    PAYMENT_VIEW_DETAILS("payment_view_details", "Voir les détails des transactions", "PAYMENT"),

    // === PERMISSIONS RAPPORTS ===
    REPORT_READ("report_read", "Lire les rapports", "REPORT"),
    REPORT_GENERATE("report_generate", "Générer des rapports", "REPORT"),
    REPORT_EXPORT("report_export", "Exporter des rapports", "REPORT"),
    REPORT_ADVANCED("report_advanced", "Accéder aux rapports avancés", "REPORT"),

    // === PERMISSIONS PARAMÈTRES ===
    SETTINGS_READ("settings_read", "Lire les paramètres", "SETTINGS"),
    SETTINGS_WRITE("settings_write", "Modifier les paramètres", "SETTINGS"),
    SETTINGS_MANAGE_NOTIFICATIONS("settings_manage_notifications", "Gérer les notifications", "SETTINGS"),

    // === PERMISSIONS SYSTÈME ===
    SYSTEM_ADMIN("system_admin", "Administration complète du système", "SYSTEM"),
    SYSTEM_BACKUP("system_backup", "Effectuer des sauvegardes", "SYSTEM"),
    SYSTEM_LOGS("system_logs", "Accéder aux logs système", "SYSTEM"),
    SYSTEM_MONITORING("system_monitoring", "Accéder au monitoring", "SYSTEM");

    private final String code;
    private final String description;
    private final String resource;

    Permission(String code, String description, String resource) {
        this.code = code;
        this.description = description;
        this.resource = resource;
    }

    /**
     * Vérifie si la permission concerne une ressource donnée
     */
    public boolean isForResource(String resourceName) {
        return this.resource.equalsIgnoreCase(resourceName);
    }

    /**
     * Obtient toutes les permissions pour une ressource
     */
    public static Permission[] getPermissionsForResource(String resourceName) {
        return java.util.Arrays.stream(Permission.values())
            .filter(permission -> permission.isForResource(resourceName))
            .toArray(Permission[]::new);
    }

    /**
     * Obtient toutes les ressources disponibles
     */
    public static String[] getAllResources() {
        return java.util.Arrays.stream(Permission.values())
            .map(Permission::getResource)
            .distinct()
            .toArray(String[]::new);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\RoleType.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

/**
 * Types de rôles prédéfinis dans le système
 */
@Getter
public enum RoleType {
    // Rôles système
    SUPER_ADMIN("super_admin", "Super Administrateur", true),

    // Rôles organisation
    ORGANIZATION_OWNER("organization_owner", "Propriétaire d'Organisation", false),
    ORGANIZATION_ADMIN("organization_admin", "Administrateur d'Organisation", false),

    // Rôles agence
    AGENCY_MANAGER("agency_manager", "Gestionnaire d'Agence", false),
    AGENCY_SUPERVISOR("agency_supervisor", "Superviseur d'Agence", false),

    // Rôles opérationnels
    RENTAL_AGENT("rental_agent", "Agent de Location", false),
    DRIVER_MANAGER("driver_manager", "Gestionnaire de Chauffeurs", false),
    VEHICLE_MANAGER("vehicle_manager", "Gestionnaire de Véhicules", false),

    // Rôles client
    CLIENT("client", "Client", false),
    VIP_CLIENT("vip_client", "Client VIP", false),

    // Rôles personnel
    RECEPTIONIST("receptionist", "Réceptionniste", false),
    MECHANIC("mechanic", "Mécanicien", false),
    DRIVER("driver", "Chauffeur", false),

    // Rôles financiers
    ACCOUNTANT("accountant", "Comptable", false),
    PAYMENT_MANAGER("payment_manager", "Gestionnaire de Paiements", false);

    private final String code;
    private final String description;
    private final boolean isSystemRole;

    RoleType(String code, String description, boolean isSystemRole) {
        this.code = code;
        this.description = description;
        this.isSystemRole = isSystemRole;
    }

    /**
     * Vérifie si le rôle est un rôle système (non modifiable)
     */
    public boolean isSystemRole() {
        return isSystemRole;
    }

    /**
     * Vérifie si le rôle est un rôle d'administration
     */
    public boolean isAdminRole() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN;
    }

    /**
     * Vérifie si le rôle est un rôle de gestion
     */
    public boolean isManagerRole() {
        return this == AGENCY_MANAGER || this == DRIVER_MANAGER || this == VEHICLE_MANAGER || this == PAYMENT_MANAGER;
    }

    /**
     * Obtient les rôles système uniquement
     */
    public static RoleType[] getSystemRoles() {
        return java.util.Arrays.stream(RoleType.values())
            .filter(RoleType::isSystemRole)
            .toArray(RoleType[]::new);
    }

    /**
     * Obtient les rôles d'organisation uniquement
     */
    public static RoleType[] getOrganizationRoles() {
        return java.util.Arrays.stream(RoleType.values())
            .filter(role -> !role.isSystemRole())
            .toArray(RoleType[]::new);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\SubscriptionFeature.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

@Getter
public enum SubscriptionFeature {
    BASIC_VEHICLE_MANAGEMENT("basic_vehicle", "Gestion basique des véhicules"),
    BASIC_DRIVER_MANAGEMENT("basic_driver", "Gestion basique des chauffeurs"),
    BASIC_RENTAL_MANAGEMENT("basic_rental", "Gestion basique des locations"),
    CHAT_SUPPORT("chat", "Support par chat"),
    GEOFENCING("geofencing", "Géofencing et tracking"),
    ADVANCED_REPORTS("advanced_reports", "Rapports avancés"),
    API_ACCESS("api_access", "Accès API"),
    PRIORITY_SUPPORT("priority_support", "Support prioritaire"),
    CUSTOM_BRANDING("custom_branding", "Personnalisation de marque"),
    UNLIMITED_USERS("unlimited_users", "Utilisateurs illimités"),
    ADVANCED_ANALYTICS("advanced_analytics", "Analytiques avancées"),
    WEBHOOK_NOTIFICATIONS("webhooks", "Notifications webhook");

    private final String code;
    private final String description;

    SubscriptionFeature(String code, String description) {
        this.code = code;
        this.description = description;
    }

    public String getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\SubscriptionPlanType.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

@Getter
public enum SubscriptionPlanType {
    GRATUIT("GRATUIT", "Forfait gratuit (30 jours)", 0),
    BASIC("BASIC", "Forfait de base", 1),
    PREMIUM("PREMIUM", "Forfait premium", 2),
    ENTERPRISE("ENTERPRISE", "Forfait entreprise", 3);

    private final String code;
    private final String description;
    private final int level;

    SubscriptionPlanType(String code, String description, int level) {
        this.code = code;
        this.description = description;
        this.level = level;
    }

    public String getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }

    public int getLevel() {
        return level;
    }

    public boolean isHigherThan(SubscriptionPlanType other) {
        return this.level > other.level;
    }

    public boolean isLowerThan(SubscriptionPlanType other) {
        return this.level < other.level;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\SubscriptionStatus.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

@Getter
public enum SubscriptionStatus {
    TRIAL("Trial", "Période d'essai"),
    ACTIVE("Active", "Souscription active"),
    EXPIRED("Expired", "Souscription expirée"),
    CANCELLED("Cancelled", "Souscription annulée"),
    SUSPENDED("Suspended", "Souscription suspendue"),
    PENDING_PAYMENT("Pending Payment", "En attente de paiement"),
    PAYMENT_FAILED("Payment Failed", "Échec du paiement");

    private final String code;
    private final String description;

    SubscriptionStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }

    public boolean isActive() {
        return this == ACTIVE || this == TRIAL;
    }

    public boolean canBeReactivated() {
        return this == SUSPENDED || this == EXPIRED;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\UserStatus.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

@Getter
public enum UserStatus {
    PENDING_VERIFICATION("pending_verification", "En attente de vérification"),
    ACTIVE("active", "Actif"),
    SUSPENDED("suspended", "Suspendu"),
    BANNED("banned", "Banni"),
    DELETED("deleted", "Supprimé");

    private final String code;
    private final String description;

    UserStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }

    public boolean isActive() {
        return this == ACTIVE;
    }

    public boolean canLogin() {
        return this == ACTIVE || this == PENDING_VERIFICATION;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\core\enums\UserType.java ---

```java
package inc.yowyob.rental_api.core.enums;

import lombok.Getter;

@Getter
public enum UserType {
    CLIENT("client", "Client final"),
    OWNER("owner", "Propriétaire d'organisation"),
    STAFF("staff", "Personnel d'organisation"),
    SUPER_ADMIN("super_admin", "Super administrateur");

    private final String code;
    private final String description;

    UserType(String code, String description) {
        this.code = code;
        this.description = description;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\driver\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\geofence\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\notification\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\controller\OnboardingController.java ---

```java
package inc.yowyob.rental_api.onboarding.controller;

import inc.yowyob.rental_api.onboarding.dto.*;
import inc.yowyob.rental_api.onboarding.service.OnboardingService;
import inc.yowyob.rental_api.subscription.entities.SubscriptionPlan;
import inc.yowyob.rental_api.subscription.service.SubscriptionService;
import inc.yowyob.rental_api.common.response.ApiResponse;
import inc.yowyob.rental_api.common.response.ApiResponseUtil;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/api/v1/onboarding")
@RequiredArgsConstructor
@Tag(name = "Onboarding", description = "APIs pour le processus d'inscription d'organisation")
public class OnboardingController {

    private final OnboardingService onboardingService;
    private final SubscriptionService subscriptionService;

    @Operation(
        summary = "Récupérer les forfaits disponibles",
        description = "Retourne la liste des forfaits d'abonnement disponibles pour l'inscription"
    )
    @GetMapping("/plans")
    public ResponseEntity<ApiResponse<List<SubscriptionPlan>>> getAvailablePlans() {
        log.info("GET /onboarding/plans - Fetching available subscription plans");

        try {
            List<SubscriptionPlan> plans = subscriptionService.getAllActivePlans();
            log.info("Successfully fetched {} subscription plans for onboarding", plans.size());

            return ApiResponseUtil.success(
                plans,
                "Forfaits d'abonnement disponibles récupérés avec succès",
                plans.size()
            );
        } catch (Exception e) {
            log.error("Error fetching subscription plans for onboarding", e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des forfaits d'abonnement",
                500
            );
        }
    }

    @Operation(
        summary = "Créer une session d'onboarding",
        description = "Démarre un nouveau processus d'inscription pour un futur propriétaire (sans utilisateur existant)"
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "201",
            description = "Session d'onboarding créée avec succès"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "500",
            description = "Erreur interne du serveur"
        )
    })
    @PostMapping("/session")
    public ResponseEntity<ApiResponse<OnboardingSessionDto>> createSession() {
        log.info("POST /onboarding/session - Creating new onboarding session");

        try {
            OnboardingSessionDto session = onboardingService.createOnboardingSession();
            log.info("Successfully created onboarding session: {}", session.getId());

            return ApiResponseUtil.created(
                session,
                "Session d'onboarding créée avec succès"
            );
        } catch (Exception e) {
            log.error("Error creating onboarding session", e);
            return ApiResponseUtil.error(
                "Erreur lors de la création de la session d'onboarding",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer une session d'onboarding",
        description = "Retourne les détails d'une session d'onboarding spécifique"
    )
    @GetMapping("/session/{sessionId}")
    public ResponseEntity<ApiResponse<OnboardingSessionDto>> getSession(
        @Parameter(description = "ID de la session d'onboarding")
        @PathVariable UUID sessionId
    ) {
        log.info("GET /onboarding/session/{} - Fetching onboarding session", sessionId);

        try {
            return onboardingService.getOnboardingSession(sessionId)
                .map(session -> {
                    log.info("Successfully fetched onboarding session: {}", sessionId);
                    return ApiResponseUtil.success(
                        session,
                        "Session d'onboarding récupérée avec succès"
                    );
                })
                .orElseGet(() -> {
                    log.warn("Onboarding session not found: {}", sessionId);
                    return ApiResponseUtil.notFound(
                        "Session d'onboarding non trouvée"
                    );
                });
        } catch (Exception e) {
            log.error("Error fetching onboarding session: {}", sessionId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération de la session d'onboarding",
                500
            );
        }
    }

    @Operation(
        summary = "Sauvegarder les informations du futur propriétaire (Étape 1)",
        description = "Sauvegarde les informations personnelles du futur propriétaire de l'organisation"
    )
    @PutMapping("/session/{sessionId}/owner-info")
    public ResponseEntity<ApiResponse<OnboardingSessionDto>> saveOwnerInfo(
        @Parameter(description = "ID de la session d'onboarding")
        @PathVariable UUID sessionId,
        @Parameter(description = "Informations du futur propriétaire")
        @Valid @RequestBody OwnerInfoDto ownerInfo
    ) {
        log.info("PUT /onboarding/session/{}/owner-info - Saving owner information", sessionId);

        try {
            OnboardingSessionDto updatedSession = onboardingService.saveOwnerInfo(sessionId, ownerInfo);
            log.info("Successfully saved owner info for session: {}", sessionId);

            return ApiResponseUtil.success(
                updatedSession,
                "Informations du propriétaire sauvegardées avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Invalid session ID or data for owner info: {}", sessionId, e);
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (IllegalStateException e) {
            log.warn("Invalid session state for owner info: {}", sessionId, e);
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (Exception e) {
            log.error("Error saving owner info for session: {}", sessionId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la sauvegarde des informations du propriétaire",
                500
            );
        }
    }

    @Operation(
        summary = "Sauvegarder les informations de l'organisation (Étape 2)",
        description = "Sauvegarde les informations et politiques de l'organisation"
    )
    @PutMapping("/session/{sessionId}/organization-info")
    public ResponseEntity<ApiResponse<OnboardingSessionDto>> saveOrganizationInfo(
        @Parameter(description = "ID de la session d'onboarding")
        @PathVariable UUID sessionId,
        @Parameter(description = "Informations de l'organisation")
        @Valid @RequestBody OrganizationInfoDto organizationInfo
    ) {
        log.info("PUT /onboarding/session/{}/organization-info - Saving organization information", sessionId);

        try {
            OnboardingSessionDto updatedSession = onboardingService.saveOrganizationInfo(sessionId, organizationInfo);
            log.info("Successfully saved organization info for session: {}", sessionId);

            return ApiResponseUtil.success(
                updatedSession,
                "Informations de l'organisation sauvegardées avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Invalid session ID or data for organization info: {}", sessionId, e);
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (IllegalStateException e) {
            log.warn("Invalid session state for organization info: {}", sessionId, e);
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (Exception e) {
            log.error("Error saving organization info for session: {}", sessionId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la sauvegarde des informations de l'organisation",
                500
            );
        }
    }

    @Operation(
        summary = "Finaliser l'onboarding (Étape 3)",
        description = "Termine le processus d'inscription avec création du compte OWNER, de l'organisation et de l'abonnement"
    )
    @PostMapping("/session/{sessionId}/complete")
    public ResponseEntity<ApiResponse<OnboardingCompletedDto>> completeOnboarding(
        @Parameter(description = "ID de la session d'onboarding")
        @PathVariable UUID sessionId,
        @Parameter(description = "Informations de souscription et paiement")
        @Valid @RequestBody SubscriptionInfoDto subscriptionInfo
    ) {
        log.info("POST /onboarding/session/{}/complete - Completing onboarding", sessionId);

        try {
            OnboardingCompletedDto result = onboardingService.completeOnboarding(sessionId, subscriptionInfo);
            log.info("Successfully completed onboarding for session: {}", sessionId);

            return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponseUtil.success(
                    result,
                    "Processus d'inscription terminé avec succès. Compte propriétaire et organisation créés."
                ).getBody());
        } catch (IllegalArgumentException e) {
            log.warn("Invalid session ID or data for completing onboarding: {}", sessionId, e);
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (IllegalStateException e) {
            log.warn("Invalid session state for completing onboarding: {}", sessionId, e);
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (Exception e) {
            log.error("Error completing onboarding for session: {}", sessionId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la finalisation du processus d'inscription",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer les informations du propriétaire",
        description = "Retourne les informations du propriétaire pour une session donnée"
    )
    @GetMapping("/session/{sessionId}/owner-info")
    public ResponseEntity<ApiResponse<OwnerInfoDto>> getOwnerInfo(
        @Parameter(description = "ID de la session d'onboarding")
        @PathVariable UUID sessionId
    ) {
        log.info("GET /onboarding/session/{}/owner-info - Fetching owner information", sessionId);

        try {
            return onboardingService.getOwnerInfo(sessionId)
                .map(ownerInfo -> {
                    log.info("Successfully fetched owner info for session: {}", sessionId);
                    return ApiResponseUtil.success(
                        ownerInfo,
                        "Informations du propriétaire récupérées avec succès"
                    );
                })
                .orElseGet(() -> {
                    log.warn("Owner info not found for session: {}", sessionId);
                    return ApiResponseUtil.notFound(
                        "Informations du propriétaire non trouvées pour cette session"
                    );
                });
        } catch (Exception e) {
            log.error("Error fetching owner info for session: {}", sessionId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des informations du propriétaire",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer les informations de l'organisation",
        description = "Retourne les informations de l'organisation pour une session donnée"
    )
    @GetMapping("/session/{sessionId}/organization-info")
    public ResponseEntity<ApiResponse<OrganizationInfoDto>> getOrganizationInfo(
        @Parameter(description = "ID de la session d'onboarding")
        @PathVariable UUID sessionId
    ) {
        log.info("GET /onboarding/session/{}/organization-info - Fetching organization information", sessionId);

        try {
            return onboardingService.getOrganizationInfo(sessionId)
                .map(organizationInfo -> {
                    log.info("Successfully fetched organization info for session: {}", sessionId);
                    return ApiResponseUtil.success(
                        organizationInfo,
                        "Informations de l'organisation récupérées avec succès"
                    );
                })
                .orElseGet(() -> {
                    log.warn("Organization info not found for session: {}", sessionId);
                    return ApiResponseUtil.notFound(
                        "Informations de l'organisation non trouvées pour cette session"
                    );
                });
        } catch (Exception e) {
            log.error("Error fetching organization info for session: {}", sessionId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des informations de l'organisation",
                500
            );
        }
    }

    @Operation(
        summary = "Annuler une session d'onboarding",
        description = "Annule le processus d'inscription en cours"
    )
    @DeleteMapping("/session/{sessionId}")
    public ResponseEntity<ApiResponse<Void>> cancelSession(
        @Parameter(description = "ID de la session d'onboarding")
        @PathVariable UUID sessionId
    ) {
        log.info("DELETE /onboarding/session/{} - Cancelling onboarding session", sessionId);

        try {
            onboardingService.cancelOnboardingSession(sessionId);
            log.info("Successfully cancelled onboarding session: {}", sessionId);

            return ApiResponseUtil.success(
                null,
                "Session d'onboarding annulée avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Invalid session ID for cancellation: {}", sessionId, e);
            return ApiResponseUtil.notFound("Session d'onboarding non trouvée");
        } catch (Exception e) {
            log.error("Error cancelling onboarding session: {}", sessionId, e);
            return ApiResponseUtil.error(
                "Erreur lors de l'annulation de la session d'onboarding",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer les statistiques d'onboarding",
        description = "Retourne les statistiques globales du processus d'inscription"
    )
    @GetMapping("/stats")
    public ResponseEntity<ApiResponse<OnboardingStatsDto>> getOnboardingStats() {
        log.info("GET /onboarding/stats - Fetching onboarding statistics");

        try {
            OnboardingStatsDto stats = onboardingService.getOnboardingStats();
            log.info("Successfully fetched onboarding statistics");

            return ApiResponseUtil.success(
                stats,
                "Statistiques d'onboarding récupérées avec succès"
            );
        } catch (Exception e) {
            log.error("Error fetching onboarding statistics", e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des statistiques d'onboarding",
                500
            );
        }
    }

    @Operation(
        summary = "Étendre la durée d'une session",
        description = "Prolonge la durée de vie d'une session d'onboarding active"
    )
    @PatchMapping("/session/{sessionId}/extend")
    public ResponseEntity<ApiResponse<OnboardingSessionDto>> extendSession(
        @Parameter(description = "ID de la session d'onboarding")
        @PathVariable UUID sessionId,
        @Parameter(description = "Nombre d'heures à ajouter (défaut: 24)")
        @RequestParam(defaultValue = "24") int additionalHours
    ) {
        log.info("PATCH /onboarding/session/{}/extend - Extending session by {} hours", sessionId, additionalHours);

        try {
            // TODO: Implémenter la méthode extendSession dans le service
            return ApiResponseUtil.success(
                null,
                "Fonctionnalité d'extension de session à implémenter"
            );
        } catch (Exception e) {
            log.error("Error extending onboarding session: {}", sessionId, e);
            return ApiResponseUtil.error(
                "Erreur lors de l'extension de la session d'onboarding",
                500
            );
        }
    }

    @Operation(
        summary = "Obtenir les sessions actives",
        description = "Retourne toutes les sessions d'onboarding actuellement en cours"
    )
    @GetMapping("/sessions/active")
    public ResponseEntity<ApiResponse<List<OnboardingSessionDto>>> getActiveSessions() {
        log.info("GET /onboarding/sessions/active - Fetching active onboarding sessions");

        try {
            // TODO: Implémenter la méthode getActiveSessions dans le service
            return ApiResponseUtil.success(
                List.of(),
                "Sessions actives récupérées avec succès (fonctionnalité à implémenter)"
            );
        } catch (Exception e) {
            log.error("Error fetching active onboarding sessions", e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des sessions actives",
                500
            );
        }
    }

    @Operation(
        summary = "Nettoyer les sessions expirées",
        description = "Met à jour le statut des sessions expirées (tâche administrative)"
    )
    @PostMapping("/sessions/cleanup")
    public ResponseEntity<ApiResponse<String>> cleanupExpiredSessions() {
        log.info("POST /onboarding/sessions/cleanup - Cleaning up expired sessions");

        try {
            onboardingService.updateExpiredSessions();
            log.info("Successfully cleaned up expired onboarding sessions");

            return ApiResponseUtil.success(
                "Nettoyage effectué avec succès",
                "Sessions expirées mises à jour"
            );
        } catch (Exception e) {
            log.error("Error cleaning up expired onboarding sessions", e);
            return ApiResponseUtil.error(
                "Erreur lors du nettoyage des sessions expirées",
                500
            );
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\dto\CompleteOnboardingDto.java ---

```java
package inc.yowyob.rental_api.onboarding.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.util.UUID;

/**
 * DTO pour la finalisation de l'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CompleteOnboardingDto {

    @NotNull(message = "Session ID is required")
    private UUID sessionId;

    @NotNull(message = "Subscription info is required")
    private SubscriptionInfoDto subscriptionInfo;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\dto\CreateOnboardingSessionDto.java ---

```java
package inc.yowyob.rental_api.onboarding.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.util.UUID;

/**
 * DTO pour la création d'une session d'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateOnboardingSessionDto {

    @NotNull(message = "User ID is required")
    private UUID userId;

    private String referralCode;
    private String campaignSource;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\dto\OnboardingCompletedDto.java ---

```java
package inc.yowyob.rental_api.onboarding.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO de réponse pour l'onboarding terminé
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OnboardingCompletedDto {

    private UUID organizationId;
    private String organizationName;
    private UUID subscriptionId;
    private String subscriptionPlan;
    private LocalDateTime activatedAt;
    private String accessToken;
    private String refreshToken;
    private String message;

    public OnboardingCompletedDto(UUID organizationId, String organizationName,
                                  UUID subscriptionId, String subscriptionPlan) {
        this.organizationId = organizationId;
        this.organizationName = organizationName;
        this.subscriptionId = subscriptionId;
        this.subscriptionPlan = subscriptionPlan;
        this.activatedAt = LocalDateTime.now();
        this.message = "Félicitations ! Votre organisation a été créée avec succès.";
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\dto\OnboardingSessionDto.java ---

```java
package inc.yowyob.rental_api.onboarding.dto;

import inc.yowyob.rental_api.core.enums.OnboardingStep;
import inc.yowyob.rental_api.core.enums.OnboardingStatus;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO de réponse pour les sessions d'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OnboardingSessionDto {

    private UUID id;
    private UUID userId;
    private OnboardingStep currentStep;
    private OnboardingStatus status;
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
    private double completionPercentage;

    // Données des étapes (masquées pour la sécurité)
    private Boolean ownerInfoCompleted;
    private Boolean organizationInfoCompleted;
    private Boolean subscriptionInfoCompleted;

    private UUID createdOrganizationId;
    private LocalDateTime completedAt;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\dto\OnboardingStatsDto.java ---

```java
package inc.yowyob.rental_api.onboarding.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * DTO pour les statistiques du processus d'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OnboardingStatsDto {

    private Long totalSessions;
    private Long completedSessions;
    private Long inProgressSessions;
    private Long expiredSessions;
    private Long cancelledSessions;
    private Long failedSessions;

    private Double completionRate; // Pourcentage de completion
    private Double abandonmentRate; // Pourcentage d'abandon

    private LocalDateTime periodStart;
    private LocalDateTime periodEnd;

    // Statistiques par étape
    private Long ownerInfoCompletions;
    private Long organizationInfoCompletions;
    private Long subscriptionCompletions;

    // Temps moyen de completion
    private Double averageCompletionTimeHours;
    private Double averageStepTimeHours;

    // Méthodes calculées
    public Double getAbandonmentRate() {
        if (totalSessions == null || totalSessions == 0) {
            return 0.0;
        }
        Long abandonedSessions = (expiredSessions != null ? expiredSessions : 0) +
            (cancelledSessions != null ? cancelledSessions : 0);
        return (double) abandonedSessions / totalSessions * 100;
    }

    public Double getInProgressRate() {
        if (totalSessions == null || totalSessions == 0) {
            return 0.0;
        }
        return (double) (inProgressSessions != null ? inProgressSessions : 0) / totalSessions * 100;
    }

    public Long getTotalFinishedSessions() {
        return (completedSessions != null ? completedSessions : 0) +
            (expiredSessions != null ? expiredSessions : 0) +
            (cancelledSessions != null ? cancelledSessions : 0) +
            (failedSessions != null ? failedSessions : 0);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\dto\OrganizationInfoDto.java ---

```java
package inc.yowyob.rental_api.onboarding.dto;

import inc.yowyob.rental_api.core.enums.OrganizationType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;

/**
 * DTO pour les informations de l'organisation (Étape 2)
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrganizationInfoDto {

    @NotBlank(message = "Organization name is required")
    @Size(min = 2, max = 100, message = "Organization name must be between 2 and 100 characters")
    private String organizationName;

    @NotNull(message = "Organization type is required")
    private OrganizationType organizationType;

    private String registrationNumber;
    private String taxNumber;

    @NotBlank(message = "Address is required")
    @Size(max = 255, message = "Address must not exceed 255 characters")
    private String address;

    @NotBlank(message = "City is required")
    @Size(max = 100, message = "City must not exceed 100 characters")
    private String city;

    @NotBlank(message = "Country is required")
    @Size(max = 100, message = "Country must not exceed 100 characters")
    private String country;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    private String description;

    @NotNull(message = "Organization policies are required")
    private OrganizationPolicyDto policies;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\dto\OrganizationPolicyDto.java ---

```java
package inc.yowyob.rental_api.onboarding.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.math.BigDecimal;

/**
 * DTO pour les politiques d'organisation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrganizationPolicyDto {

    @NotNull(message = "With driver option is required")
    private Boolean withDriverOption = true;

    @NotNull(message = "Without driver option is required")
    private Boolean withoutDriverOption = true;

    @NotNull(message = "Driver mandatory setting is required")
    private Boolean driverMandatory = false;

    @NotNull(message = "Minimum rental hours is required")
    @Min(value = 1, message = "Minimum rental hours must be at least 1")
    @Max(value = 168, message = "Minimum rental hours cannot exceed 168 (1 week)")
    private Integer minRentalHours = 1;

    @NotNull(message = "Security deposit is required")
    @PositiveOrZero(message = "Security deposit must be positive or zero")
    private BigDecimal securityDeposit = BigDecimal.ZERO;

    @NotNull(message = "Late return penalty is required")
    @PositiveOrZero(message = "Late return penalty must be positive or zero")
    private BigDecimal lateReturnPenalty = BigDecimal.ZERO;

    @NotNull(message = "Cancellation policy is required")
    @Size(max = 1000, message = "Cancellation policy must not exceed 1000 characters")
    private String cancellationPolicy = "Annulation gratuite jusqu'à 24h avant la location";

    private Boolean allowWeekendRental = true;
    private Boolean allowHolidayRental = true;
    private Boolean requireDriverLicense = true;
    private Integer minDriverAge = 21;
    private Integer maxDriverAge = 75;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\dto\OwnerInfoDto.java ---

```java
package inc.yowyob.rental_api.onboarding.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.time.LocalDate;

/**
 * DTO pour les informations du propriétaire (Étape 1)
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OwnerInfoDto {

    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;

    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;

    @NotBlank(message = "Phone is required")
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    private String phone;

    @NotBlank(message = "ID card number is required")
    private String idCardNumber;

    @NotBlank(message = "Address is required")
    @Size(max = 255, message = "Address must not exceed 255 characters")
    private String address;

    @NotBlank(message = "City is required")
    @Size(max = 100, message = "City must not exceed 100 characters")
    private String city;

    @NotBlank(message = "Country is required")
    @Size(max = 100, message = "Country must not exceed 100 characters")
    private String country;

    @Past(message = "Date of birth must be in the past")
    private LocalDate dateOfBirth;

    private String nationality;
    private String profession;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\dto\SubscriptionInfoDto.java ---

```java
package inc.yowyob.rental_api.onboarding.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.util.UUID;

/**
 * DTO pour les informations de souscription (Étape 3)
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SubscriptionInfoDto {

    @NotNull(message = "Subscription plan ID is required")
    private UUID subscriptionPlanId;

    @NotNull(message = "Payment method is required")
    private String paymentMethod; // MOMO, ORANGE_MONEY, VISA, etc.

    private String paymentToken;
    private String paymentReference;

    @NotNull(message = "Accept terms is required")
    @AssertTrue(message = "You must accept the terms and conditions")
    private Boolean acceptTerms = false;

    @NotNull(message = "Accept privacy policy is required")
    @AssertTrue(message = "You must accept the privacy policy")
    private Boolean acceptPrivacyPolicy = false;

    private Boolean optInMarketing = false;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\entities\OnboardingSession.java ---

```java
package inc.yowyob.rental_api.onboarding.entities;

import inc.yowyob.rental_api.core.enums.OnboardingStatus;
import inc.yowyob.rental_api.core.enums.OnboardingStep;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Session d'onboarding pour suivre le processus d'inscription d'un futur propriétaire
 */
@Data
@AllArgsConstructor
@Table("onboarding_sessions")
public class OnboardingSession {

    @Id
    @PrimaryKey
    private UUID id;

    private UUID userId;

    @NotNull(message = "Current step is required")
    private OnboardingStep currentStep;

    @NotNull(message = "Status is required")
    private OnboardingStatus status;

    // JSON string contenant les données de chaque étape
    private String ownerInfoData;
    private String organizationInfoData;
    private String subscriptionInfoData;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private LocalDateTime expiresAt;

    // Informations de completion
    private LocalDateTime completedAt;
    private UUID createdOrganizationId;

    /**
     * Constructeur par défaut pour une nouvelle session
     */
    public OnboardingSession(boolean initializeDefaults) {
        if (initializeDefaults) {
            this.id = UUID.randomUUID();
            this.userId = null; // Pas d'utilisateur au début
            this.currentStep = OnboardingStep.OWNER_INFO;
            this.status = OnboardingStatus.IN_PROGRESS;
            this.createdAt = LocalDateTime.now();
            this.updatedAt = LocalDateTime.now();
            this.expiresAt = LocalDateTime.now().plusHours(24); // Session expire après 24h
        }
    }

    /**
     * Constructeur par défaut qui initialise les valeurs
     */
    public OnboardingSession() {
        this(true);
    }

    // ==================== MÉTHODES MÉTIER ====================

    /**
     * Vérifie si la session a expiré
     */
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt);
    }

    /**
     * Vérifie si la session est terminée
     */
    public boolean isCompleted() {
        return status == OnboardingStatus.COMPLETED;
    }

    /**
     * Vérifie si on peut procéder à une étape donnée
     */
    public boolean canProceedToStep(OnboardingStep step) {
        return switch (step) {
            case OWNER_INFO -> true; // Toujours possible
            case ORGANIZATION_INFO -> currentStep.ordinal() >= OnboardingStep.OWNER_INFO.ordinal()
                && ownerInfoData != null && !ownerInfoData.trim().isEmpty();
            case SUBSCRIPTION_PAYMENT -> currentStep.ordinal() >= OnboardingStep.ORGANIZATION_INFO.ordinal()
                && organizationInfoData != null && !organizationInfoData.trim().isEmpty();
        };
    }

    /**
     * Passe à l'étape suivante
     */
    public void moveToNextStep() {
        OnboardingStep[] steps = OnboardingStep.values();
        int currentIndex = currentStep.ordinal();
        if (currentIndex < steps.length - 1) {
            this.currentStep = steps[currentIndex + 1];
            this.updatedAt = LocalDateTime.now();
        }
    }

    /**
     * Met à jour les informations du propriétaire et passe à l'étape suivante
     */
    public void updateOwnerInfo(String ownerInfoJson) {
        this.ownerInfoData = ownerInfoJson;
        this.updatedAt = LocalDateTime.now();

        // Passer à l'étape suivante si on est encore à la première étape
        if (currentStep == OnboardingStep.OWNER_INFO) {
            moveToNextStep();
        }
    }

    /**
     * Met à jour les informations de l'organisation et passe à l'étape suivante
     */
    public void updateOrganizationInfo(String organizationInfoJson) {
        this.organizationInfoData = organizationInfoJson;
        this.updatedAt = LocalDateTime.now();

        // Passer à l'étape suivante si on est à l'étape organisation
        if (currentStep == OnboardingStep.ORGANIZATION_INFO) {
            moveToNextStep();
        }
    }

    /**
     * Met à jour les informations de souscription
     */
    public void updateSubscriptionInfo(String subscriptionInfoJson) {
        this.subscriptionInfoData = subscriptionInfoJson;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Marque la session comme terminée avec succès
     */
    public void complete(UUID organizationId) {
        this.status = OnboardingStatus.COMPLETED;
        this.completedAt = LocalDateTime.now();
        this.createdOrganizationId = organizationId;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Marque la session comme expirée
     */
    public void expire() {
        this.status = OnboardingStatus.EXPIRED;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Marque la session comme annulée
     */
    public void cancel() {
        this.status = OnboardingStatus.CANCELLED;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Marque la session comme échouée
     */
    public void fail() {
        this.status = OnboardingStatus.FAILED;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Calcule le pourcentage de completion
     */
    public double getCompletionPercentage() {
        if (status == OnboardingStatus.COMPLETED) {
            return 100.0;
        }

        int totalSteps = OnboardingStep.values().length;
        int completedSteps = 0;

        // Compter les étapes complétées
        if (ownerInfoData != null && !ownerInfoData.trim().isEmpty()) {
            completedSteps++;
        }
        if (organizationInfoData != null && !organizationInfoData.trim().isEmpty()) {
            completedSteps++;
        }
        if (subscriptionInfoData != null && !subscriptionInfoData.trim().isEmpty()) {
            completedSteps++;
        }

        return (double) completedSteps / totalSteps * 100.0;
    }

    /**
     * Vérifie si la session peut être modifiée
     */
    public boolean canBeModified() {
        return status == OnboardingStatus.IN_PROGRESS && !isExpired();
    }

    /**
     * Étend la durée de vie de la session
     */
    public void extendExpiry(int additionalHours) {
        if (canBeModified()) {
            this.expiresAt = this.expiresAt.plusHours(additionalHours);
            this.updatedAt = LocalDateTime.now();
        }
    }

    /**
     * Réinitialise la session à l'état initial
     */
    public void reset() {
        this.currentStep = OnboardingStep.OWNER_INFO;
        this.status = OnboardingStatus.IN_PROGRESS;
        this.ownerInfoData = null;
        this.organizationInfoData = null;
        this.subscriptionInfoData = null;
        this.completedAt = null;
        this.createdOrganizationId = null;
        this.updatedAt = LocalDateTime.now();
        this.expiresAt = LocalDateTime.now().plusHours(24);
    }

    /**
     * Obtient un résumé du statut de la session
     */
    public String getStatusSummary() {
        if (isCompleted()) {
            return "Session terminée avec succès";
        }
        if (isExpired()) {
            return "Session expirée";
        }
        if (status == OnboardingStatus.CANCELLED) {
            return "Session annulée";
        }
        if (status == OnboardingStatus.FAILED) {
            return "Session échouée";
        }

        return String.format("En cours - Étape %d/%d (%.0f%%)",
            currentStep.ordinal() + 1,
            OnboardingStep.values().length,
            getCompletionPercentage());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\repository\OnboardingSessionRepository.java ---

```java
package inc.yowyob.rental_api.onboarding.repository;

import inc.yowyob.rental_api.core.enums.OnboardingStatus;
import inc.yowyob.rental_api.onboarding.entities.OnboardingSession;
import org.springframework.data.cassandra.repository.CassandraRepository;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface OnboardingSessionRepository extends CassandraRepository<OnboardingSession, UUID> {

    /**
     * Trouve la session active d'un utilisateur (si elle existe)
     * Note: Peut retourner vide car l'utilisateur n'existe pas forcément au début
     */
    @Query("SELECT * FROM onboarding_sessions WHERE user_id = ?0 AND status = 'IN_PROGRESS' ALLOW FILTERING")
    Optional<OnboardingSession> findActiveByUserId(UUID userId);

    /**
     * Trouve toutes les sessions d'un utilisateur
     */
    @Query("SELECT * FROM onboarding_sessions WHERE user_id = ?0 ALLOW FILTERING")
    List<OnboardingSession> findAllByUserId(UUID userId);

    /**
     * Trouve les sessions par statut
     */
    @Query("SELECT * FROM onboarding_sessions WHERE status = ?0 ALLOW FILTERING")
    List<OnboardingSession> findAllByStatus(OnboardingStatus status);

    /**
     * Trouve les sessions expirées qui sont encore marquées comme en cours
     */
    @Query("SELECT * FROM onboarding_sessions WHERE expires_at < ?0 AND status = 'IN_PROGRESS' ALLOW FILTERING")
    List<OnboardingSession> findExpiredSessions(LocalDateTime now);

    /**
     * Trouve les sessions créées dans une période donnée
     */
    @Query("SELECT * FROM onboarding_sessions WHERE created_at >= ?0 AND created_at <= ?1 ALLOW FILTERING")
    List<OnboardingSession> findByCreatedAtBetween(LocalDateTime startDate, LocalDateTime endDate);

    /**
     * Trouve les sessions terminées avec succès
     */
    @Query("SELECT * FROM onboarding_sessions WHERE status = 'COMPLETED' ALLOW FILTERING")
    List<OnboardingSession> findCompletedSessions();

    /**
     * Trouve les sessions terminées avec succès dans une période
     */
    @Query("SELECT * FROM onboarding_sessions WHERE status = 'COMPLETED' AND completed_at >= ?0 AND completed_at <= ?1 ALLOW FILTERING")
    List<OnboardingSession> findCompletedBetween(LocalDateTime startDate, LocalDateTime endDate);

    /**
     * Compte les sessions par statut
     */
    @Query("SELECT COUNT(*) FROM onboarding_sessions WHERE status = ?0 ALLOW FILTERING")
    Long countByStatus(OnboardingStatus status);

    /**
     * Trouve les sessions en cours depuis plus de X heures (sessions "stales")
     */
    @Query("SELECT * FROM onboarding_sessions WHERE status = 'IN_PROGRESS' AND created_at < ?0 ALLOW FILTERING")
    List<OnboardingSession> findStaleInProgressSessions(LocalDateTime cutoffTime);

    /**
     * Trouve les sessions par organisation créée
     */
    @Query("SELECT * FROM onboarding_sessions WHERE created_organization_id = ?0 ALLOW FILTERING")
    List<OnboardingSession> findByCreatedOrganizationId(UUID organizationId);

    /**
     * Trouve les sessions sans utilisateur associé (sessions en début de processus)
     */
    @Query("SELECT * FROM onboarding_sessions WHERE user_id IS NULL AND status = 'IN_PROGRESS' ALLOW FILTERING")
    List<OnboardingSession> findSessionsWithoutUser();

    /**
     * Trouve les sessions qui ont des informations propriétaire mais pas d'utilisateur créé
     */
    @Query("SELECT * FROM onboarding_sessions WHERE user_id IS NULL AND owner_info_data IS NOT NULL ALLOW FILTERING")
    List<OnboardingSession> findSessionsWithOwnerInfoButNoUser();

    /**
     * Trouve les sessions abandonnées (créées mais jamais mises à jour)
     */
    @Query("SELECT * FROM onboarding_sessions WHERE status = 'IN_PROGRESS' AND owner_info_data IS NULL AND created_at < ?0 ALLOW FILTERING")
    List<OnboardingSession> findAbandonedSessions(LocalDateTime cutoffTime);

    /**
     * Trouve les sessions en cours d'une étape spécifique
     */
    @Query("SELECT * FROM onboarding_sessions WHERE current_step = ?0 AND status = 'IN_PROGRESS' ALLOW FILTERING")
    List<OnboardingSession> findByCurrentStepAndInProgress(String currentStep);

    /**
     * Trouve les sessions créées aujourd'hui
     */
    @Query("SELECT * FROM onboarding_sessions WHERE created_at >= ?0 ALLOW FILTERING")
    List<OnboardingSession> findCreatedSince(LocalDateTime since);

    /**
     * Trouve les sessions qui vont expirer bientôt
     */
    @Query("SELECT * FROM onboarding_sessions WHERE status = 'IN_PROGRESS' AND expires_at <= ?0 AND expires_at > ?1 ALLOW FILTERING")
    List<OnboardingSession> findExpiringSoon(LocalDateTime expirationThreshold, LocalDateTime now);

    /**
     * Compte le nombre total de sessions créées
     */
    @Query("SELECT COUNT(*) FROM onboarding_sessions")
    Long countTotal();

    /**
     * Trouve les sessions avec des données d'organisation mais pas encore terminées
     */
    @Query("SELECT * FROM onboarding_sessions WHERE organization_info_data IS NOT NULL AND status = 'IN_PROGRESS' ALLOW FILTERING")
    List<OnboardingSession> findSessionsWithOrganizationInfo();

    /**
     * Trouve les sessions par période et statut pour les statistiques
     */
    @Query("SELECT * FROM onboarding_sessions WHERE status = ?0 AND created_at >= ?1 AND created_at <= ?2 ALLOW FILTERING")
    List<OnboardingSession> findByStatusAndPeriod(OnboardingStatus status, LocalDateTime startDate, LocalDateTime endDate);
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\onboarding\service\OnboardingService.java ---

```java
package inc.yowyob.rental_api.onboarding.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import inc.yowyob.rental_api.core.enums.OnboardingStatus;
import inc.yowyob.rental_api.core.enums.OnboardingStep;
import inc.yowyob.rental_api.core.enums.UserStatus;
import inc.yowyob.rental_api.core.enums.UserType;
import inc.yowyob.rental_api.onboarding.dto.*;
import inc.yowyob.rental_api.onboarding.entities.OnboardingSession;
import inc.yowyob.rental_api.onboarding.repository.OnboardingSessionRepository;
import inc.yowyob.rental_api.subscription.entities.OrganizationSubscription;
import inc.yowyob.rental_api.subscription.entities.SubscriptionPlan;
import inc.yowyob.rental_api.subscription.service.SubscriptionService;
import inc.yowyob.rental_api.user.entities.User;
import inc.yowyob.rental_api.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class OnboardingService {

    private final OnboardingSessionRepository onboardingSessionRepository;
    private final SubscriptionService subscriptionService;
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final ObjectMapper objectMapper;

    /**
     * Crée une nouvelle session d'onboarding pour un futur propriétaire
     * Note: L'utilisateur n'existe PAS encore - nous créons juste une session
     */
    public OnboardingSessionDto createOnboardingSession() {
        log.info("Creating new onboarding session for future owner");

        // Créer une session sans userId car l'utilisateur n'existe pas encore
        OnboardingSession session = new OnboardingSession();
        OnboardingSession saved = onboardingSessionRepository.save(session);

        log.info("Created new onboarding session: {}", saved.getId());
        return mapToDto(saved);
    }

    /**
     * Récupère une session d'onboarding par ID
     */
    public Optional<OnboardingSessionDto> getOnboardingSession(UUID sessionId) {
        log.debug("Fetching onboarding session: {}", sessionId);
        return onboardingSessionRepository.findById(sessionId)
            .map(this::mapToDto);
    }

    /**
     * Sauvegarde les informations du futur propriétaire (Étape 1)
     */
    @Transactional
    public OnboardingSessionDto saveOwnerInfo(UUID sessionId, OwnerInfoDto ownerInfo) {
        log.info("Saving owner info for session: {}", sessionId);

        OnboardingSession session = getSessionOrThrow(sessionId);
        validateSessionActive(session);

        // Vérifier que l'email n'existe pas déjà
        if (userRepository.existsByEmail(ownerInfo.getEmail())) {
            throw new IllegalArgumentException("Un utilisateur avec cet email existe déjà. Veuillez vous connecter ou utiliser un autre email.");
        }

        try {
            String ownerInfoJson = objectMapper.writeValueAsString(ownerInfo);
            session.updateOwnerInfo(ownerInfoJson);

            OnboardingSession updated = onboardingSessionRepository.save(session);
            log.info("Owner info saved for session: {}", sessionId);

            return mapToDto(updated);
        } catch (JsonProcessingException e) {
            log.error("Error serializing owner info for session: {}", sessionId, e);
            throw new RuntimeException("Error saving owner information", e);
        }
    }

    /**
     * Sauvegarde les informations de l'organisation (Étape 2)
     */
    @Transactional
    public OnboardingSessionDto saveOrganizationInfo(UUID sessionId, OrganizationInfoDto organizationInfo) {
        log.info("Saving organization info for session: {}", sessionId);

        OnboardingSession session = getSessionOrThrow(sessionId);
        validateSessionActive(session);

        if (!session.canProceedToStep(OnboardingStep.ORGANIZATION_INFO)) {
            throw new IllegalStateException("Cannot proceed to organization info step. Complete previous steps first.");
        }

        try {
            String organizationInfoJson = objectMapper.writeValueAsString(organizationInfo);
            session.updateOrganizationInfo(organizationInfoJson);

            OnboardingSession updated = onboardingSessionRepository.save(session);
            log.info("Organization info saved for session: {}", sessionId);

            return mapToDto(updated);
        } catch (JsonProcessingException e) {
            log.error("Error serializing organization info for session: {}", sessionId, e);
            throw new RuntimeException("Error saving organization information", e);
        }
    }

    /**
     * Finalise le processus d'onboarding (Étape 3)
     * CRÉATION EFFECTIVE DE L'UTILISATEUR OWNER ET DE L'ORGANISATION
     */
    @Transactional
    public OnboardingCompletedDto completeOnboarding(UUID sessionId, SubscriptionInfoDto subscriptionInfo) {
        log.info("Completing onboarding for session: {}", sessionId);

        OnboardingSession session = getSessionOrThrow(sessionId);
        validateSessionActive(session);

        if (!session.canProceedToStep(OnboardingStep.SUBSCRIPTION_PAYMENT)) {
            throw new IllegalStateException("Cannot proceed to subscription step. Complete previous steps first.");
        }

        try {
            // Récupérer les données des étapes précédentes
            OwnerInfoDto ownerInfo = objectMapper.readValue(session.getOwnerInfoData(), OwnerInfoDto.class);
            OrganizationInfoDto organizationInfo = objectMapper.readValue(session.getOrganizationInfoData(), OrganizationInfoDto.class);

            // Vérifier encore une fois que l'email n'existe pas
            if (userRepository.existsByEmail(ownerInfo.getEmail())) {
                throw new IllegalArgumentException("Un utilisateur avec cet email existe déjà");
            }

            // 1. CRÉER L'UTILISATEUR OWNER
            User owner = createOwnerUser(ownerInfo);
            log.info("Owner user created with ID: {}", owner.getId());

            // 2. CRÉER L'ORGANISATION (simulation pour l'instant)
            UUID organizationId = createOrganization(organizationInfo, owner.getId());
            log.info("Organization created with ID: {}", organizationId);

            // 3. LIER L'UTILISATEUR À L'ORGANISATION
            owner.setOrganizationId(organizationId);
            userRepository.save(owner);

            // 4. CRÉER L'ABONNEMENT
            SubscriptionPlan plan = subscriptionService.getPlanById(subscriptionInfo.getSubscriptionPlanId())
                .orElseThrow(() -> new IllegalArgumentException("Plan d'abonnement non trouvé"));

            OrganizationSubscription subscription = subscriptionService.createSubscription(
                organizationId,
                subscriptionInfo.getSubscriptionPlanId(),
                subscriptionInfo.getPaymentMethod(),
                subscriptionInfo.getPaymentReference(),
                plan.getPrice()
            );

            // 5. SAUVEGARDER LES INFOS DE SOUSCRIPTION
            String subscriptionInfoJson = objectMapper.writeValueAsString(subscriptionInfo);
            session.updateSubscriptionInfo(subscriptionInfoJson);

            // 6. MARQUER LA SESSION COMME TERMINÉE
            session.complete(organizationId);
            session.setUserId(owner.getId()); // Maintenant on peut lier l'utilisateur
            onboardingSessionRepository.save(session);

            log.info("Onboarding completed successfully for session: {}", sessionId);

            // 7. TODO: Envoyer email de bienvenue avec mot de passe temporaire
            // sendWelcomeEmail(owner, temporaryPassword);

            return new OnboardingCompletedDto(
                organizationId,
                organizationInfo.getOrganizationName(),
                subscription.getId(),
                plan.getName()
            );

        } catch (JsonProcessingException e) {
            log.error("Error processing onboarding completion for session: {}", sessionId, e);
            throw new RuntimeException("Error completing onboarding", e);
        }
    }

    /**
     * Récupère les informations du propriétaire pour une session
     */
    public Optional<OwnerInfoDto> getOwnerInfo(UUID sessionId) {
        log.debug("Fetching owner info for session: {}", sessionId);

        return onboardingSessionRepository.findById(sessionId)
            .filter(session -> session.getOwnerInfoData() != null)
            .map(session -> {
                try {
                    return objectMapper.readValue(session.getOwnerInfoData(), OwnerInfoDto.class);
                } catch (JsonProcessingException e) {
                    log.error("Error deserializing owner info for session: {}", sessionId, e);
                    return null;
                }
            });
    }

    /**
     * Récupère les informations de l'organisation pour une session
     */
    public Optional<OrganizationInfoDto> getOrganizationInfo(UUID sessionId) {
        log.debug("Fetching organization info for session: {}", sessionId);

        return onboardingSessionRepository.findById(sessionId)
            .filter(session -> session.getOrganizationInfoData() != null)
            .map(session -> {
                try {
                    return objectMapper.readValue(session.getOrganizationInfoData(), OrganizationInfoDto.class);
                } catch (JsonProcessingException e) {
                    log.error("Error deserializing organization info for session: {}", sessionId, e);
                    return null;
                }
            });
    }

    /**
     * Annule une session d'onboarding
     */
    @Transactional
    public void cancelOnboardingSession(UUID sessionId) {
        log.info("Cancelling onboarding session: {}", sessionId);

        OnboardingSession session = getSessionOrThrow(sessionId);
        session.setStatus(OnboardingStatus.CANCELLED);
        session.setUpdatedAt(LocalDateTime.now());

        onboardingSessionRepository.save(session);
        log.info("Onboarding session cancelled: {}", sessionId);
    }

    /**
     * Met à jour les sessions expirées
     */
    @Transactional
    public void updateExpiredSessions() {
        log.info("Updating expired onboarding sessions");

        List<OnboardingSession> expiredSessions = onboardingSessionRepository.findExpiredSessions(LocalDateTime.now());

        for (OnboardingSession session : expiredSessions) {
            session.expire();
            onboardingSessionRepository.save(session);
        }

        log.info("Updated {} expired onboarding sessions", expiredSessions.size());
    }

    /**
     * Récupère les statistiques d'onboarding
     */
    public OnboardingStatsDto getOnboardingStats() {
        log.debug("Fetching onboarding statistics");

        Long totalSessions = onboardingSessionRepository.count();
        Long completedSessions = onboardingSessionRepository.countByStatus(OnboardingStatus.COMPLETED);
        Long inProgressSessions = onboardingSessionRepository.countByStatus(OnboardingStatus.IN_PROGRESS);
        Long expiredSessions = onboardingSessionRepository.countByStatus(OnboardingStatus.EXPIRED);
        Long cancelledSessions = onboardingSessionRepository.countByStatus(OnboardingStatus.CANCELLED);

        double completionRate = totalSessions > 0 ? (double) completedSessions / totalSessions * 100 : 0.0;

        return OnboardingStatsDto.builder()
            .totalSessions(totalSessions)
            .completedSessions(completedSessions)
            .inProgressSessions(inProgressSessions)
            .expiredSessions(expiredSessions)
            .cancelledSessions(cancelledSessions)
            .completionRate(completionRate)
            .build();
    }

    /**
     * Trouve les sessions inactives depuis longtemps
     */
    public List<OnboardingSession> findStaleSessions(int hoursThreshold) {
        LocalDateTime cutoffTime = LocalDateTime.now().minusHours(hoursThreshold);
        return onboardingSessionRepository.findStaleInProgressSessions(cutoffTime);
    }

    // ==================== MÉTHODES PRIVÉES ====================

    /**
     * Crée l'utilisateur propriétaire à partir des informations d'onboarding
     */
    private User createOwnerUser(OwnerInfoDto ownerInfo) {
        log.info("Creating owner user for email: {}", ownerInfo.getEmail());

        // Générer un mot de passe temporaire sécurisé
        String temporaryPassword = generateSecureTemporaryPassword();

        User owner = new User(
            ownerInfo.getEmail(),
            passwordEncoder.encode(temporaryPassword),
            ownerInfo.getFirstName(),
            ownerInfo.getLastName(),
            UserType.OWNER
        );

        owner.setPhone(ownerInfo.getPhone());
        owner.setAddress(ownerInfo.getAddress());
        owner.setCity(ownerInfo.getCity());
        owner.setCountry(ownerInfo.getCountry());
        owner.setStatus(UserStatus.ACTIVE); // Directement actif pour les propriétaires après onboarding
        owner.setEmailVerified(false); // Sera vérifié par email
        owner.setPhoneVerified(false);

        User savedOwner = userRepository.save(owner);

        // TODO: Envoyer email avec mot de passe temporaire
        log.info("Temporary password for {}: {} (TODO: Send via email)", ownerInfo.getEmail(), temporaryPassword);

        return savedOwner;
    }

    /**
     * Crée l'organisation (simulation pour l'instant - sera implémenté en Phase 5)
     */
    private UUID createOrganization(OrganizationInfoDto organizationInfo, UUID ownerId) {
        log.info("Creating organization: {} for owner: {}", organizationInfo.getOrganizationName(), ownerId);

        // TODO: Implémenter la création réelle de l'organisation en Phase 5
        // Pour l'instant, retourner un UUID simulé
        UUID organizationId = UUID.randomUUID();

        log.info("Organization created (simulated) with ID: {} - will be implemented in Phase 5", organizationId);
        return organizationId;
    }

    /**
     * Génère un mot de passe temporaire sécurisé
     */
    private String generateSecureTemporaryPassword() {
        String upperCase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String lowerCase = "abcdefghijklmnopqrstuvwxyz";
        String digits = "0123456789";
        String specialChars = "!@#$%&*";
        String allChars = upperCase + lowerCase + digits + specialChars;

        SecureRandom random = new SecureRandom();
        StringBuilder password = new StringBuilder(12);

        // Garantir au moins un caractère de chaque type
        password.append(upperCase.charAt(random.nextInt(upperCase.length())));
        password.append(lowerCase.charAt(random.nextInt(lowerCase.length())));
        password.append(digits.charAt(random.nextInt(digits.length())));
        password.append(specialChars.charAt(random.nextInt(specialChars.length())));

        // Compléter avec des caractères aléatoires
        for (int i = 4; i < 12; i++) {
            password.append(allChars.charAt(random.nextInt(allChars.length())));
        }

        // Mélanger les caractères
        for (int i = 0; i < password.length(); i++) {
            int randomIndex = random.nextInt(password.length());
            char temp = password.charAt(i);
            password.setCharAt(i, password.charAt(randomIndex));
            password.setCharAt(randomIndex, temp);
        }

        return password.toString();
    }

    /**
     * Récupère une session ou lance une exception
     */
    private OnboardingSession getSessionOrThrow(UUID sessionId) {
        return onboardingSessionRepository.findById(sessionId)
            .orElseThrow(() -> new IllegalArgumentException("Onboarding session not found: " + sessionId));
    }

    /**
     * Valide qu'une session est active et utilisable
     */
    private void validateSessionActive(OnboardingSession session) {
        if (session.isExpired()) {
            throw new IllegalStateException("Onboarding session has expired");
        }

        if (session.isCompleted()) {
            throw new IllegalStateException("Onboarding session is already completed");
        }

        if (session.getStatus() != OnboardingStatus.IN_PROGRESS) {
            throw new IllegalStateException("Onboarding session is not in progress");
        }
    }

    /**
     * Convertit une session en DTO
     */
    private OnboardingSessionDto mapToDto(OnboardingSession session) {
        OnboardingSessionDto dto = new OnboardingSessionDto();
        dto.setId(session.getId());
        dto.setUserId(session.getUserId()); // Peut être null au début
        dto.setCurrentStep(session.getCurrentStep());
        dto.setStatus(session.getStatus());
        dto.setCreatedAt(session.getCreatedAt());
        dto.setExpiresAt(session.getExpiresAt());
        dto.setCompletionPercentage(session.getCompletionPercentage());

        // Indiquer quelles étapes sont complétées
        dto.setOwnerInfoCompleted(session.getOwnerInfoData() != null);
        dto.setOrganizationInfoCompleted(session.getOrganizationInfoData() != null);
        dto.setSubscriptionInfoCompleted(session.getSubscriptionInfoData() != null);

        dto.setCreatedOrganizationId(session.getCreatedOrganizationId());
        dto.setCompletedAt(session.getCompletedAt());

        return dto;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\organization\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\payment\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\rental\readme.md ---

```markdown

```

--- PATH: src\main\java\inc\yowyob\rental_api\role\config\RoleDataInitializer.java ---

```java
package inc.yowyob.rental_api.role.config;

import inc.yowyob.rental_api.core.enums.Permission;
import inc.yowyob.rental_api.core.enums.RoleType;
import inc.yowyob.rental_api.role.entities.Role;
import inc.yowyob.rental_api.role.repository.RoleRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.Set;
import java.util.UUID;

/**
 * Initialise les rôles système par défaut
 */
@Slf4j
@Component
@Order(3) // Après UserDataInitializer
@RequiredArgsConstructor
public class RoleDataInitializer implements CommandLineRunner {

    private final RoleRepository roleRepository;

    @Override
    public void run(String... args) throws Exception {
        log.info("Initializing system roles data...");

        try {
            createSystemRoles();
            log.info("System roles initialization completed successfully.");

        } catch (Exception e) {
            log.error("Error during system roles initialization: {}", e.getMessage(), e);
        }
    }

    private void createSystemRoles() {
        log.info("Creating system roles...");

        try {
            // Créer le rôle Super Admin système
            createSuperAdminRole();

            log.info("System roles creation completed successfully.");

        } catch (Exception e) {
            log.error("Error creating system roles: {}", e.getMessage(), e);
            throw e;
        }
    }

    private void createSuperAdminRole() {
        // Vérifier si le rôle Super Admin existe déjà
        if (roleRepository.findSystemRoles().stream()
            .anyMatch(role -> RoleType.SUPER_ADMIN.equals(role.getRoleType()))) {
            log.info("Super Admin system role already exists. Skipping creation.");
            return;
        }

        log.info("Creating Super Admin system role...");

        // ID d'organisation système (null ou UUID spécial pour les rôles système)
        UUID systemOrgId = UUID.fromString("00000000-0000-0000-0000-000000000000");

        Role superAdminRole = new Role(
            "Super Administrateur",
            "Administrateur système avec tous les droits sur la plateforme",
            systemOrgId,
            RoleType.SUPER_ADMIN
        );

        // Marquer comme rôle système
        superAdminRole.setIsSystemRole(true);
        superAdminRole.setIsDefaultRole(false);
        superAdminRole.setPriority(1000); // Priorité maximale
        superAdminRole.setColor("#FF0000"); // Rouge pour indiquer le niveau élevé
        superAdminRole.setIcon("shield-check");

        // Ajouter TOUTES les permissions système
        Set<String> allPermissions = Set.of(
            // Permissions système complètes
            Permission.SYSTEM_ADMIN.getCode(),
            Permission.SYSTEM_BACKUP.getCode(),
            Permission.SYSTEM_LOGS.getCode(),
            Permission.SYSTEM_MONITORING.getCode(),

            // Permissions organisations (pour gérer toutes les organisations)
            Permission.ORGANIZATION_READ.getCode(),
            Permission.ORGANIZATION_UPDATE.getCode(),
            Permission.ORGANIZATION_MANAGE_SETTINGS.getCode(),
            Permission.ORGANIZATION_MANAGE_SUBSCRIPTION.getCode(),

            // Permissions agences
            Permission.AGENCY_READ.getCode(),
            Permission.AGENCY_WRITE.getCode(),
            Permission.AGENCY_UPDATE.getCode(),
            Permission.AGENCY_DELETE.getCode(),
            Permission.AGENCY_MANAGE_STAFF.getCode(),

            // Permissions utilisateurs
            Permission.USER_READ.getCode(),
            Permission.USER_WRITE.getCode(),
            Permission.USER_UPDATE.getCode(),
            Permission.USER_DELETE.getCode(),
            Permission.USER_MANAGE_ROLES.getCode(),
            Permission.USER_RESET_PASSWORD.getCode(),

            // Permissions rôles
            Permission.ROLE_READ.getCode(),
            Permission.ROLE_WRITE.getCode(),
            Permission.ROLE_UPDATE.getCode(),
            Permission.ROLE_DELETE.getCode(),
            Permission.ROLE_ASSIGN_PERMISSIONS.getCode(),

            // Permissions véhicules
            Permission.VEHICLE_READ.getCode(),
            Permission.VEHICLE_WRITE.getCode(),
            Permission.VEHICLE_UPDATE.getCode(),
            Permission.VEHICLE_DELETE.getCode(),
            Permission.VEHICLE_MANAGE_IMAGES.getCode(),
            Permission.VEHICLE_CHANGE_STATUS.getCode(),

            // Permissions chauffeurs
            Permission.DRIVER_READ.getCode(),
            Permission.DRIVER_WRITE.getCode(),
            Permission.DRIVER_UPDATE.getCode(),
            Permission.DRIVER_DELETE.getCode(),
            Permission.DRIVER_MANAGE_DOCUMENTS.getCode(),
            Permission.DRIVER_MANAGE_SCHEDULE.getCode(),

            // Permissions locations
            Permission.RENTAL_READ.getCode(),
            Permission.RENTAL_WRITE.getCode(),
            Permission.RENTAL_UPDATE.getCode(),
            Permission.RENTAL_DELETE.getCode(),
            Permission.RENTAL_APPROVE.getCode(),
            Permission.RENTAL_CANCEL.getCode(),
            Permission.RENTAL_EXTEND.getCode(),

            // Permissions paiements
            Permission.PAYMENT_READ.getCode(),
            Permission.PAYMENT_PROCESS.getCode(),
            Permission.PAYMENT_REFUND.getCode(),
            Permission.PAYMENT_VIEW_DETAILS.getCode(),

            // Permissions rapports
            Permission.REPORT_READ.getCode(),
            Permission.REPORT_GENERATE.getCode(),
            Permission.REPORT_EXPORT.getCode(),
            Permission.REPORT_ADVANCED.getCode(),

            // Permissions paramètres
            Permission.SETTINGS_READ.getCode(),
            Permission.SETTINGS_WRITE.getCode(),
            Permission.SETTINGS_MANAGE_NOTIFICATIONS.getCode()
        );

        superAdminRole.setPermissions(allPermissions);
        superAdminRole.setCreatedAt(LocalDateTime.now());
        superAdminRole.setUpdatedAt(LocalDateTime.now());

        roleRepository.save(superAdminRole);
        log.info("Super Admin system role created successfully with {} permissions", allPermissions.size());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\config\RolePermissionConfig.java ---

```java
package inc.yowyob.rental_api.role.config;

import inc.yowyob.rental_api.core.enums.Permission;
import inc.yowyob.rental_api.core.enums.RoleType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Map;
import java.util.Set;

/**
 * Configuration des permissions par défaut pour les différents types de rôles
 */
@Slf4j
@Configuration
public class RolePermissionConfig {

    /**
     * Définit les permissions par défaut pour chaque type de rôle
     */
    @Bean
    public Map<RoleType, Set<String>> defaultRolePermissions() {
        return Map.ofEntries(
            Map.entry(RoleType.SUPER_ADMIN, getSuperAdminPermissions()),
            Map.entry(RoleType.ORGANIZATION_OWNER, getOrganizationOwnerPermissions()),
            Map.entry(RoleType.ORGANIZATION_ADMIN, getOrganizationAdminPermissions()),
            Map.entry(RoleType.AGENCY_MANAGER, getAgencyManagerPermissions()),
            Map.entry(RoleType.AGENCY_SUPERVISOR, getAgencySupervisorPermissions()),
            Map.entry(RoleType.RENTAL_AGENT, getRentalAgentPermissions()),
            Map.entry(RoleType.DRIVER_MANAGER, getDriverManagerPermissions()),
            Map.entry(RoleType.VEHICLE_MANAGER, getVehicleManagerPermissions()),
            Map.entry(RoleType.CLIENT, getClientPermissions()),
            Map.entry(RoleType.VIP_CLIENT, getVipClientPermissions()),
            Map.entry(RoleType.RECEPTIONIST, getReceptionistPermissions()),
            Map.entry(RoleType.MECHANIC, getMechanicPermissions()),
            Map.entry(RoleType.DRIVER, getDriverPermissions()),
            Map.entry(RoleType.ACCOUNTANT, getAccountantPermissions()),
            Map.entry(RoleType.PAYMENT_MANAGER, getPaymentManagerPermissions())
        );
    }

    private Set<String> getSuperAdminPermissions() {
        // Toutes les permissions système
        return Set.of(
            Permission.SYSTEM_ADMIN.getCode(),
            Permission.SYSTEM_BACKUP.getCode(),
            Permission.SYSTEM_LOGS.getCode(),
            Permission.SYSTEM_MONITORING.getCode()
            // + toutes les autres permissions...
        );
    }

    private Set<String> getOrganizationOwnerPermissions() {
        return Set.of(
            // Gestion complète de l'organisation
            Permission.ORGANIZATION_READ.getCode(),
            Permission.ORGANIZATION_UPDATE.getCode(),
            Permission.ORGANIZATION_MANAGE_SETTINGS.getCode(),
            Permission.ORGANIZATION_MANAGE_SUBSCRIPTION.getCode(),

            // Gestion complète des agences
            Permission.AGENCY_READ.getCode(),
            Permission.AGENCY_WRITE.getCode(),
            Permission.AGENCY_UPDATE.getCode(),
            Permission.AGENCY_DELETE.getCode(),
            Permission.AGENCY_MANAGE_STAFF.getCode(),

            // Gestion complète des utilisateurs
            Permission.USER_READ.getCode(),
            Permission.USER_WRITE.getCode(),
            Permission.USER_UPDATE.getCode(),
            Permission.USER_DELETE.getCode(),
            Permission.USER_MANAGE_ROLES.getCode(),
            Permission.USER_RESET_PASSWORD.getCode(),

            // Gestion complète des rôles
            Permission.ROLE_READ.getCode(),
            Permission.ROLE_WRITE.getCode(),
            Permission.ROLE_UPDATE.getCode(),
            Permission.ROLE_DELETE.getCode(),
            Permission.ROLE_ASSIGN_PERMISSIONS.getCode(),

            // Accès complet aux rapports
            Permission.REPORT_READ.getCode(),
            Permission.REPORT_GENERATE.getCode(),
            Permission.REPORT_EXPORT.getCode(),
            Permission.REPORT_ADVANCED.getCode(),

            // Gestion des paramètres
            Permission.SETTINGS_READ.getCode(),
            Permission.SETTINGS_WRITE.getCode(),
            Permission.SETTINGS_MANAGE_NOTIFICATIONS.getCode()
        );
    }

    private Set<String> getOrganizationAdminPermissions() {
        return Set.of(
            // Lecture de l'organisation
            Permission.ORGANIZATION_READ.getCode(),
            Permission.ORGANIZATION_MANAGE_SETTINGS.getCode(),

            // Gestion des agences
            Permission.AGENCY_READ.getCode(),
            Permission.AGENCY_WRITE.getCode(),
            Permission.AGENCY_UPDATE.getCode(),
            Permission.AGENCY_MANAGE_STAFF.getCode(),

            // Gestion des utilisateurs
            Permission.USER_READ.getCode(),
            Permission.USER_WRITE.getCode(),
            Permission.USER_UPDATE.getCode(),
            Permission.USER_MANAGE_ROLES.getCode(),

            // Gestion des rôles (limitée)
            Permission.ROLE_READ.getCode(),
            Permission.ROLE_WRITE.getCode(),
            Permission.ROLE_UPDATE.getCode(),

            // Rapports
            Permission.REPORT_READ.getCode(),
            Permission.REPORT_GENERATE.getCode(),
            Permission.REPORT_EXPORT.getCode(),

            // Paramètres
            Permission.SETTINGS_READ.getCode(),
            Permission.SETTINGS_WRITE.getCode()
        );
    }

    private Set<String> getAgencyManagerPermissions() {
        return Set.of(
            // Lecture agence
            Permission.AGENCY_READ.getCode(),
            Permission.AGENCY_UPDATE.getCode(),

            // Gestion complète des véhicules de l'agence
            Permission.VEHICLE_READ.getCode(),
            Permission.VEHICLE_WRITE.getCode(),
            Permission.VEHICLE_UPDATE.getCode(),
            Permission.VEHICLE_DELETE.getCode(),
            Permission.VEHICLE_MANAGE_IMAGES.getCode(),
            Permission.VEHICLE_CHANGE_STATUS.getCode(),

            // Gestion complète des chauffeurs de l'agence
            Permission.DRIVER_READ.getCode(),
            Permission.DRIVER_WRITE.getCode(),
            Permission.DRIVER_UPDATE.getCode(),
            Permission.DRIVER_DELETE.getCode(),
            Permission.DRIVER_MANAGE_DOCUMENTS.getCode(),
            Permission.DRIVER_MANAGE_SCHEDULE.getCode(),

            // Gestion complète des locations
            Permission.RENTAL_READ.getCode(),
            Permission.RENTAL_WRITE.getCode(),
            Permission.RENTAL_UPDATE.getCode(),
            Permission.RENTAL_DELETE.getCode(),
            Permission.RENTAL_APPROVE.getCode(),
            Permission.RENTAL_CANCEL.getCode(),
            Permission.RENTAL_EXTEND.getCode(),

            // Personnel de l'agence
            Permission.USER_READ.getCode(),
            Permission.USER_WRITE.getCode(),
            Permission.USER_UPDATE.getCode(),

            // Rapports de l'agence
            Permission.REPORT_READ.getCode(),
            Permission.REPORT_GENERATE.getCode(),

            // Paramètres de base
            Permission.SETTINGS_READ.getCode()
        );
    }

    private Set<String> getAgencySupervisorPermissions() {
        return Set.of(
            // Lecture agence
            Permission.AGENCY_READ.getCode(),

            // Gestion des véhicules (sans suppression)
            Permission.VEHICLE_READ.getCode(),
            Permission.VEHICLE_UPDATE.getCode(),
            Permission.VEHICLE_CHANGE_STATUS.getCode(),

            // Gestion des chauffeurs (sans suppression)
            Permission.DRIVER_READ.getCode(),
            Permission.DRIVER_UPDATE.getCode(),
            Permission.DRIVER_MANAGE_SCHEDULE.getCode(),

            // Gestion des locations
            Permission.RENTAL_READ.getCode(),
            Permission.RENTAL_WRITE.getCode(),
            Permission.RENTAL_UPDATE.getCode(),
            Permission.RENTAL_APPROVE.getCode(),
            Permission.RENTAL_CANCEL.getCode(),

            // Personnel (lecture seule)
            Permission.USER_READ.getCode(),

            // Rapports
            Permission.REPORT_READ.getCode(),
            Permission.REPORT_GENERATE.getCode()
        );
    }

    private Set<String> getRentalAgentPermissions() {
        return Set.of(
            // Lecture des véhicules
            Permission.VEHICLE_READ.getCode(),

            // Lecture des chauffeurs
            Permission.DRIVER_READ.getCode(),

            // Gestion des locations
            Permission.RENTAL_READ.getCode(),
            Permission.RENTAL_WRITE.getCode(),
            Permission.RENTAL_UPDATE.getCode(),

            // Clients
            Permission.USER_READ.getCode()
        );
    }

    private Set<String> getDriverManagerPermissions() {
        return Set.of(
            // Gestion complète des chauffeurs
            Permission.DRIVER_READ.getCode(),
            Permission.DRIVER_WRITE.getCode(),
            Permission.DRIVER_UPDATE.getCode(),
            Permission.DRIVER_DELETE.getCode(),
            Permission.DRIVER_MANAGE_DOCUMENTS.getCode(),
            Permission.DRIVER_MANAGE_SCHEDULE.getCode(),

            // Lecture des véhicules pour assignation
            Permission.VEHICLE_READ.getCode(),

            // Gestion des locations liées aux chauffeurs
            Permission.RENTAL_READ.getCode(),
            Permission.RENTAL_UPDATE.getCode(),

            // Rapports chauffeurs
            Permission.REPORT_READ.getCode(),
            Permission.REPORT_GENERATE.getCode()
        );
    }

    private Set<String> getVehicleManagerPermissions() {
        return Set.of(
            // Gestion complète des véhicules
            Permission.VEHICLE_READ.getCode(),
            Permission.VEHICLE_WRITE.getCode(),
            Permission.VEHICLE_UPDATE.getCode(),
            Permission.VEHICLE_DELETE.getCode(),
            Permission.VEHICLE_MANAGE_IMAGES.getCode(),
            Permission.VEHICLE_CHANGE_STATUS.getCode(),

            // Lecture des chauffeurs pour assignation
            Permission.DRIVER_READ.getCode(),

            // Lecture des locations
            Permission.RENTAL_READ.getCode(),

            // Rapports véhicules
            Permission.REPORT_READ.getCode(),
            Permission.REPORT_GENERATE.getCode()
        );
    }

    private Set<String> getClientPermissions() {
        return Set.of(
            // Lecture des véhicules disponibles
            Permission.VEHICLE_READ.getCode(),

            // Lecture des chauffeurs disponibles
            Permission.DRIVER_READ.getCode(),

            // Gestion de ses propres locations
            Permission.RENTAL_READ.getCode(),
            Permission.RENTAL_WRITE.getCode()
        );
    }

    private Set<String> getVipClientPermissions() {
        return Set.of(
            // Toutes les permissions client
            Permission.VEHICLE_READ.getCode(),
            Permission.DRIVER_READ.getCode(),
            Permission.RENTAL_READ.getCode(),
            Permission.RENTAL_WRITE.getCode(),

            // Permissions supplémentaires VIP
            Permission.RENTAL_EXTEND.getCode(), // Peut prolonger ses locations
            Permission.REPORT_READ.getCode()    // Peut voir ses rapports de location
        );
    }

    private Set<String> getReceptionistPermissions() {
        return Set.of(
            // Lecture des véhicules
            Permission.VEHICLE_READ.getCode(),

            // Lecture des chauffeurs
            Permission.DRIVER_READ.getCode(),

            // Gestion des locations (accueil client)
            Permission.RENTAL_READ.getCode(),
            Permission.RENTAL_WRITE.getCode(),
            Permission.RENTAL_UPDATE.getCode(),

            // Gestion des clients
            Permission.USER_READ.getCode(),
            Permission.USER_WRITE.getCode()
        );
    }

    private Set<String> getMechanicPermissions() {
        return Set.of(
            // Lecture et mise à jour des véhicules (maintenance)
            Permission.VEHICLE_READ.getCode(),
            Permission.VEHICLE_UPDATE.getCode(),
            Permission.VEHICLE_CHANGE_STATUS.getCode(),

            // Lecture des locations (pour planifier maintenance)
            Permission.RENTAL_READ.getCode()
        );
    }

    private Set<String> getDriverPermissions() {
        return Set.of(
            // Lecture des véhicules assignés
            Permission.VEHICLE_READ.getCode(),

            // Lecture de ses informations
            Permission.DRIVER_READ.getCode(),

            // Lecture de ses locations
            Permission.RENTAL_READ.getCode()
        );
    }

    private Set<String> getAccountantPermissions() {
        return Set.of(
            // Lecture pour facturation
            Permission.RENTAL_READ.getCode(),
            Permission.USER_READ.getCode(),
            Permission.VEHICLE_READ.getCode(),
            Permission.DRIVER_READ.getCode(),

            // Gestion complète des paiements
            Permission.PAYMENT_READ.getCode(),
            Permission.PAYMENT_PROCESS.getCode(),
            Permission.PAYMENT_REFUND.getCode(),
            Permission.PAYMENT_VIEW_DETAILS.getCode(),

            // Rapports financiers
            Permission.REPORT_READ.getCode(),
            Permission.REPORT_GENERATE.getCode(),
            Permission.REPORT_EXPORT.getCode(),
            Permission.REPORT_ADVANCED.getCode()
        );
    }

    private Set<String> getPaymentManagerPermissions() {
        return Set.of(
            // Lecture pour paiements
            Permission.RENTAL_READ.getCode(),
            Permission.USER_READ.getCode(),

            // Gestion complète des paiements
            Permission.PAYMENT_READ.getCode(),
            Permission.PAYMENT_PROCESS.getCode(),
            Permission.PAYMENT_REFUND.getCode(),
            Permission.PAYMENT_VIEW_DETAILS.getCode(),

            // Rapports paiements
            Permission.REPORT_READ.getCode(),
            Permission.REPORT_GENERATE.getCode()
        );
    }

    /**
     * Obtient les descriptions des types de rôles pour l'interface utilisateur
     */
    @Bean
    public Map<RoleType, String> roleTypeDescriptions() {
        return Map.ofEntries(
            Map.entry(RoleType.SUPER_ADMIN, "Administrateur système avec accès complet à toute la plateforme"),
            Map.entry(RoleType.ORGANIZATION_OWNER, "Propriétaire de l'organisation avec droits complets sur son organisation"),
            Map.entry(RoleType.ORGANIZATION_ADMIN, "Administrateur d'organisation avec droits étendus"),
            Map.entry(RoleType.AGENCY_MANAGER, "Gestionnaire d'agence avec droits complets sur son agence"),
            Map.entry(RoleType.AGENCY_SUPERVISOR, "Superviseur d'agence avec droits de supervision"),
            Map.entry(RoleType.RENTAL_AGENT, "Agent de location responsable des réservations clients"),
            Map.entry(RoleType.DRIVER_MANAGER, "Gestionnaire spécialisé dans la gestion des chauffeurs"),
            Map.entry(RoleType.VEHICLE_MANAGER, "Gestionnaire spécialisé dans la gestion des véhicules"),
            Map.entry(RoleType.CLIENT, "Client standard avec accès aux fonctionnalités de location"),
            Map.entry(RoleType.VIP_CLIENT, "Client VIP avec privilèges étendus"),
            Map.entry(RoleType.RECEPTIONIST, "Réceptionniste gérant l'accueil et les premières interactions"),
            Map.entry(RoleType.MECHANIC, "Mécanicien responsable de la maintenance des véhicules"),
            Map.entry(RoleType.DRIVER, "Chauffeur avec accès limité aux informations nécessaires"),
            Map.entry(RoleType.ACCOUNTANT, "Comptable gérant les aspects financiers"),
            Map.entry(RoleType.PAYMENT_MANAGER, "Gestionnaire spécialisé dans les paiements")
        );
    }

    /**
     * Obtient les couleurs par défaut pour chaque type de rôle
     */
    @Bean
    public Map<RoleType, String> roleTypeColors() {
        return Map.ofEntries(
            Map.entry(RoleType.SUPER_ADMIN, "#FF0000"),
            Map.entry(RoleType.ORGANIZATION_OWNER, "#FF6B35"),
            Map.entry(RoleType.ORGANIZATION_ADMIN, "#FF8C42"),
            Map.entry(RoleType.AGENCY_MANAGER, "#4ECDC4"),
            Map.entry(RoleType.AGENCY_SUPERVISOR, "#45B7D1"),
            Map.entry(RoleType.RENTAL_AGENT, "#96CEB4"),
            Map.entry(RoleType.DRIVER_MANAGER, "#FECA57"),
            Map.entry(RoleType.VEHICLE_MANAGER, "#FF9FF3"),
            Map.entry(RoleType.CLIENT, "#A8E6CF"),
            Map.entry(RoleType.VIP_CLIENT, "#FFD93D"),
            Map.entry(RoleType.RECEPTIONIST, "#88D8C0"),
            Map.entry(RoleType.MECHANIC, "#FFA726"),
            Map.entry(RoleType.DRIVER, "#81C784"),
            Map.entry(RoleType.ACCOUNTANT, "#9575CD"),
            Map.entry(RoleType.PAYMENT_MANAGER, "#7986CB")
        );
    }

    /**
     * Obtient les icônes par défaut pour chaque type de rôle
     */
    @Bean
    public Map<RoleType, String> roleTypeIcons() {
        return Map.ofEntries(
            Map.entry(RoleType.SUPER_ADMIN, "shield-check"),
            Map.entry(RoleType.ORGANIZATION_OWNER, "crown"),
            Map.entry(RoleType.ORGANIZATION_ADMIN, "settings"),
            Map.entry(RoleType.AGENCY_MANAGER, "building"),
            Map.entry(RoleType.AGENCY_SUPERVISOR, "eye"),
            Map.entry(RoleType.RENTAL_AGENT, "clipboard-list"),
            Map.entry(RoleType.DRIVER_MANAGER, "users"),
            Map.entry(RoleType.VEHICLE_MANAGER, "truck"),
            Map.entry(RoleType.CLIENT, "user"),
            Map.entry(RoleType.VIP_CLIENT, "star"),
            Map.entry(RoleType.RECEPTIONIST, "phone"),
            Map.entry(RoleType.MECHANIC, "wrench"),
            Map.entry(RoleType.DRIVER, "steering-wheel"),
            Map.entry(RoleType.ACCOUNTANT, "calculator"),
            Map.entry(RoleType.PAYMENT_MANAGER, "credit-card")
        );
    }

    /**
     * Vérifie la cohérence des permissions configurées
     */
    public boolean validatePermissionConfiguration() {
        Map<RoleType, Set<String>> permissions = defaultRolePermissions();

        log.info("Validating role permission configuration...");

        // Vérifier que tous les codes de permission existent
        Set<String> validPermissions = Set.of(Permission.values())
            .stream()
            .map(Permission::getCode)
            .collect(java.util.stream.Collectors.toSet());

        boolean isValid = true;

        for (Map.Entry<RoleType, Set<String>> entry : permissions.entrySet()) {
            RoleType roleType = entry.getKey();
            Set<String> rolePermissions = entry.getValue();

            for (String permission : rolePermissions) {
                if (!validPermissions.contains(permission)) {
                    log.error("Invalid permission '{}' configured for role type '{}'", permission, roleType);
                    isValid = false;
                }
            }

            log.debug("Role type '{}' has {} permissions configured", roleType, rolePermissions.size());
        }

        if (isValid) {
            log.info("Role permission configuration is valid");
        } else {
            log.error("Role permission configuration contains errors");
        }

        return isValid;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\controller\RoleController.java ---

```java
package inc.yowyob.rental_api.role.controller;

import inc.yowyob.rental_api.common.response.ApiResponse;
import inc.yowyob.rental_api.common.response.ApiResponseUtil;
import inc.yowyob.rental_api.role.dto.*;
import inc.yowyob.rental_api.role.service.RoleService;
import inc.yowyob.rental_api.security.util.SecurityUtils;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/api/v1/roles")
@RequiredArgsConstructor
@Tag(name = "Role Management", description = "APIs de gestion des rôles et permissions")
public class RoleController {

    private final RoleService roleService;

    @Operation(
        summary = "Créer un nouveau rôle",
        description = "Crée un nouveau rôle avec les permissions spécifiées pour une organisation"
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "201",
            description = "Rôle créé avec succès"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400",
            description = "Données d'entrée invalides"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403",
            description = "Permissions insuffisantes"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "409",
            description = "Un rôle avec ce nom existe déjà"
        )
    })
    @PostMapping
    @PreAuthorize("hasAuthority('ROLE_WRITE')")
    public ResponseEntity<ApiResponse<RoleDto>> createRole(
        @Parameter(description = "Informations du nouveau rôle")
        @Valid @RequestBody CreateRoleDto createRoleDto
    ) {
        log.info("POST /roles - Creating new role: {}", createRoleDto.getName());

        try {
            UUID currentUserId = SecurityUtils.getCurrentUserId();
            RoleDto createdRole = roleService.createRole(createRoleDto, currentUserId);

            log.info("Role created successfully with ID: {}", createdRole.getId());

            return ApiResponseUtil.created(
                createdRole,
                "Rôle créé avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Invalid data for role creation: {}", e.getMessage());
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (Exception e) {
            log.error("Error creating role", e);
            return ApiResponseUtil.error(
                "Erreur lors de la création du rôle",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer un rôle par ID",
        description = "Retourne les détails d'un rôle spécifique"
    )
    @GetMapping("/{roleId}")
    @PreAuthorize("hasAuthority('ROLE_READ')")
    public ResponseEntity<ApiResponse<RoleDto>> getRoleById(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId
    ) {
        log.info("GET /roles/{} - Fetching role", roleId);

        try {
            RoleDto role = roleService.getRoleById(roleId);

            return ApiResponseUtil.success(
                role,
                "Rôle récupéré avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Role not found: {}", roleId);
            return ApiResponseUtil.notFound("Rôle non trouvé");
        } catch (Exception e) {
            log.error("Error fetching role: {}", roleId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération du rôle",
                500
            );
        }
    }

    @Operation(
        summary = "Mettre à jour un rôle",
        description = "Met à jour les informations d'un rôle existant"
    )
    @PutMapping("/{roleId}")
    @PreAuthorize("hasAuthority('ROLE_UPDATE')")
    public ResponseEntity<ApiResponse<RoleDto>> updateRole(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId,
        @Parameter(description = "Nouvelles informations du rôle")
        @Valid @RequestBody UpdateRoleDto updateRoleDto
    ) {
        log.info("PUT /roles/{} - Updating role", roleId);

        try {
            UUID currentUserId = SecurityUtils.getCurrentUserId();
            RoleDto updatedRole = roleService.updateRole(roleId, updateRoleDto, currentUserId);

            return ApiResponseUtil.success(
                updatedRole,
                "Rôle mis à jour avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Invalid data for role update: {}", e.getMessage());
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (IllegalStateException e) {
            log.warn("Cannot update role: {}", e.getMessage());
            return ApiResponseUtil.forbidden(e.getMessage());
        } catch (Exception e) {
            log.error("Error updating role: {}", roleId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la mise à jour du rôle",
                500
            );
        }
    }

    @Operation(
        summary = "Supprimer un rôle",
        description = "Supprime un rôle existant (si aucun utilisateur ne l'a assigné)"
    )
    @DeleteMapping("/{roleId}")
    @PreAuthorize("hasAuthority('ROLE_DELETE')")
    public ResponseEntity<ApiResponse<Void>> deleteRole(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId
    ) {
        log.info("DELETE /roles/{} - Deleting role", roleId);

        try {
            roleService.deleteRole(roleId);

            return ApiResponseUtil.success(
                null,
                "Rôle supprimé avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Role not found for deletion: {}", roleId);
            return ApiResponseUtil.notFound("Rôle non trouvé");
        } catch (IllegalStateException e) {
            log.warn("Cannot delete role: {}", e.getMessage());
            return ApiResponseUtil.forbidden(e.getMessage());
        } catch (Exception e) {
            log.error("Error deleting role: {}", roleId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la suppression du rôle",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer les rôles d'une organisation",
        description = "Retourne tous les rôles d'une organisation spécifique"
    )
    @GetMapping("/organization/{organizationId}")
    @PreAuthorize("hasAuthority('ROLE_READ')")
    public ResponseEntity<ApiResponse<List<RoleDto>>> getRolesByOrganization(
        @Parameter(description = "ID de l'organisation")
        @PathVariable UUID organizationId,
        @Parameter(description = "Inclure uniquement les rôles actifs")
        @RequestParam(defaultValue = "false") boolean activeOnly
    ) {
        log.info("GET /roles/organization/{} - Fetching roles (activeOnly: {})", organizationId, activeOnly);

        try {
            List<RoleDto> roles = activeOnly
                ? roleService.getActiveRolesByOrganizationId(organizationId)
                : roleService.getRolesByOrganizationId(organizationId);

            return ApiResponseUtil.success(
                roles,
                "Rôles récupérés avec succès",
                roles.size()
            );
        } catch (Exception e) {
            log.error("Error fetching roles for organization: {}", organizationId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des rôles",
                500
            );
        }
    }

    @Operation(
        summary = "Assigner un rôle à un utilisateur",
        description = "Assigne un rôle spécifique à un utilisateur"
    )
    @PostMapping("/assign")
    @PreAuthorize("hasAuthority('USER_MANAGE_ROLES')")
    public ResponseEntity<ApiResponse<UserRoleDto>> assignRole(
        @Parameter(description = "Informations d'assignation du rôle")
        @Valid @RequestBody AssignRoleDto assignRoleDto
    ) {
        log.info("POST /roles/assign - Assigning role {} to user {}",
            assignRoleDto.getRoleId(), assignRoleDto.getUserId());

        try {
            UUID currentUserId = SecurityUtils.getCurrentUserId();
            UserRoleDto userRole = roleService.assignRole(assignRoleDto, currentUserId);

            return ApiResponseUtil.created(
                userRole,
                "Rôle assigné avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Invalid data for role assignment: {}", e.getMessage());
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (IllegalStateException e) {
            log.warn("Cannot assign role: {}", e.getMessage());
            return ApiResponseUtil.conflict(e.getMessage());
        } catch (Exception e) {
            log.error("Error assigning role", e);
            return ApiResponseUtil.error(
                "Erreur lors de l'assignation du rôle",
                500
            );
        }
    }

    @Operation(
        summary = "Révoquer un rôle d'un utilisateur",
        description = "Retire un rôle spécifique d'un utilisateur"
    )
    @DeleteMapping("/revoke/{userId}/{roleId}")
    @PreAuthorize("hasAuthority('USER_MANAGE_ROLES')")
    public ResponseEntity<ApiResponse<Void>> revokeRole(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId
    ) {
        log.info("DELETE /roles/revoke/{}/{} - Revoking role", userId, roleId);

        try {
            roleService.revokeRole(userId, roleId);

            return ApiResponseUtil.success(
                null,
                "Rôle révoqué avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Role assignment not found: {}", e.getMessage());
            return ApiResponseUtil.notFound("Assignation de rôle non trouvée");
        } catch (Exception e) {
            log.error("Error revoking role", e);
            return ApiResponseUtil.error(
                "Erreur lors de la révocation du rôle",
                500
            );
        }
    }

    @Operation(
        summary = "Assignation en masse de rôles",
        description = "Assigne un rôle à plusieurs utilisateurs en une seule opération"
    )
    @PostMapping("/bulk-assign")
    @PreAuthorize("hasAuthority('USER_MANAGE_ROLES')")
    public ResponseEntity<ApiResponse<List<UserRoleDto>>> bulkAssignRole(
        @Parameter(description = "Informations d'assignation en masse")
        @Valid @RequestBody BulkAssignRoleDto bulkAssignRoleDto
    ) {
        log.info("POST /roles/bulk-assign - Bulk assigning role {} to {} users",
            bulkAssignRoleDto.getRoleId(), bulkAssignRoleDto.getUserIds().size());

        try {
            UUID currentUserId = SecurityUtils.getCurrentUserId();
            List<UserRoleDto> assignments = roleService.bulkAssignRole(bulkAssignRoleDto, currentUserId);

            return ApiResponseUtil.success(
                assignments,
                String.format("Rôle assigné à %d utilisateur(s) avec succès", assignments.size()),
                assignments.size()
            );
        } catch (Exception e) {
            log.error("Error in bulk role assignment", e);
            return ApiResponseUtil.error(
                "Erreur lors de l'assignation en masse",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer les rôles d'un utilisateur",
        description = "Retourne tous les rôles assignés à un utilisateur spécifique"
    )
    @GetMapping("/user/{userId}")
    @PreAuthorize("hasAuthority('USER_READ') or #userId == authentication.principal.id")
    public ResponseEntity<ApiResponse<List<UserRoleDto>>> getUserRoles(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId
    ) {
        log.info("GET /roles/user/{} - Fetching user roles", userId);

        try {
            List<UserRoleDto> userRoles = roleService.getUserRoles(userId);

            return ApiResponseUtil.success(
                userRoles,
                "Rôles de l'utilisateur récupérés avec succès",
                userRoles.size()
            );
        } catch (Exception e) {
            log.error("Error fetching user roles: {}", userId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des rôles de l'utilisateur",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer les permissions effectives d'un utilisateur",
        description = "Calcule et retourne toutes les permissions qu'un utilisateur possède via ses rôles"
    )
    @GetMapping("/user/{userId}/permissions")
    @PreAuthorize("hasAuthority('USER_READ') or #userId == authentication.principal.id")
    public ResponseEntity<ApiResponse<UserPermissionsDto>> getUserPermissions(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @Parameter(description = "ID de l'organisation")
        @RequestParam UUID organizationId
    ) {
        log.info("GET /roles/user/{}/permissions - Fetching user permissions for org {}", userId, organizationId);

        try {
            UserPermissionsDto permissions = roleService.getUserEffectivePermissions(userId, organizationId);

            return ApiResponseUtil.success(
                permissions,
                "Permissions de l'utilisateur récupérées avec succès"
            );
        } catch (Exception e) {
            log.error("Error fetching user permissions: {}", userId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des permissions",
                500
            );
        }
    }

    @Operation(
        summary = "Mettre à jour les permissions d'un rôle",
        description = "Met à jour la liste des permissions assignées à un rôle"
    )
    @PutMapping("/{roleId}/permissions")
    @PreAuthorize("hasAuthority('ROLE_ASSIGN_PERMISSIONS')")
    public ResponseEntity<ApiResponse<RoleDto>> updateRolePermissions(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId,
        @Parameter(description = "Nouvelles permissions du rôle")
        @Valid @RequestBody RolePermissionsDto rolePermissionsDto
    ) {
        log.info("PUT /roles/{}/permissions - Updating role permissions", roleId);

        try {
            // Vérifier que l'ID du rôle correspond
            if (!roleId.equals(rolePermissionsDto.getRoleId())) {
                return ApiResponseUtil.badRequest("L'ID du rôle ne correspond pas");
            }

            UUID currentUserId = SecurityUtils.getCurrentUserId();
            RoleDto updatedRole = roleService.updateRolePermissions(rolePermissionsDto, currentUserId);

            return ApiResponseUtil.success(
                updatedRole,
                "Permissions du rôle mises à jour avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Invalid data for permissions update: {}", e.getMessage());
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (IllegalStateException e) {
            log.warn("Cannot update permissions: {}", e.getMessage());
            return ApiResponseUtil.forbidden(e.getMessage());
        } catch (Exception e) {
            log.error("Error updating role permissions: {}", roleId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la mise à jour des permissions",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer toutes les permissions disponibles",
        description = "Retourne toutes les permissions du système groupées par ressource"
    )
    @GetMapping("/permissions")
    @PreAuthorize("hasAuthority('ROLE_READ')")
    public ResponseEntity<ApiResponse<List<PermissionGroupDto>>> getAllPermissions() {
        log.info("GET /roles/permissions - Fetching all available permissions");

        try {
            List<PermissionGroupDto> permissionGroups = roleService.getAllPermissionsGrouped();

            return ApiResponseUtil.success(
                permissionGroups,
                "Permissions récupérées avec succès",
                permissionGroups.size()
            );
        } catch (Exception e) {
            log.error("Error fetching permissions", e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des permissions",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer les statistiques des rôles",
        description = "Retourne les statistiques des rôles pour une organisation"
    )
    @GetMapping("/stats/{organizationId}")
    @PreAuthorize("hasAuthority('ROLE_READ')")
    public ResponseEntity<ApiResponse<RoleStatsDto>> getRoleStats(
        @Parameter(description = "ID de l'organisation")
        @PathVariable UUID organizationId
    ) {
        log.info("GET /roles/stats/{} - Fetching role statistics", organizationId);

        try {
            RoleStatsDto stats = roleService.getRoleStats(organizationId);

            return ApiResponseUtil.success(
                stats,
                "Statistiques des rôles récupérées avec succès"
            );
        } catch (Exception e) {
            log.error("Error fetching role statistics: {}", organizationId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des statistiques",
                500
            );
        }
    }

    @Operation(
        summary = "Créer les rôles par défaut",
        description = "Crée les rôles par défaut pour une nouvelle organisation"
    )
    @PostMapping("/default/{organizationId}")
    @PreAuthorize("hasAuthority('ROLE_WRITE')")
    public ResponseEntity<ApiResponse<List<RoleDto>>> createDefaultRoles(
        @Parameter(description = "ID de l'organisation")
        @PathVariable UUID organizationId
    ) {
        log.info("POST /roles/default/{} - Creating default roles", organizationId);

        try {
            UUID currentUserId = SecurityUtils.getCurrentUserId();
            List<RoleDto> createdRoles = roleService.createDefaultRoles(organizationId, currentUserId);

            return ApiResponseUtil.created(
                createdRoles,
                String.format("%d rôles par défaut créés avec succès", createdRoles.size())
            );
        } catch (Exception e) {
            log.error("Error creating default roles for organization: {}", organizationId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la création des rôles par défaut",
                500
            );
        }
    }

    @Operation(
        summary = "Nettoyer les assignations expirées",
        description = "Met à jour le statut des assignations de rôles expirées (tâche administrative)"
    )
    @PostMapping("/cleanup-expired")
    @PreAuthorize("hasAuthority('SYSTEM_ADMIN')")
    public ResponseEntity<ApiResponse<String>> cleanupExpiredAssignments() {
        log.info("POST /roles/cleanup-expired - Cleaning up expired assignments");

        try {
            roleService.cleanupExpiredAssignments();

            return ApiResponseUtil.success(
                "Nettoyage effectué avec succès",
                "Assignations expirées mises à jour"
            );
        } catch (Exception e) {
            log.error("Error cleaning up expired assignments", e);
            return ApiResponseUtil.error(
                "Erreur lors du nettoyage des assignations expirées",
                500
            );
        }
    }

    @Operation(
        summary = "Activer/Désactiver un rôle",
        description = "Change le statut actif/inactif d'un rôle"
    )
    @PatchMapping("/{roleId}/toggle-status")
    @PreAuthorize("hasAuthority('ROLE_UPDATE')")
    public ResponseEntity<ApiResponse<RoleDto>> toggleRoleStatus(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId
    ) {
        log.info("PATCH /roles/{}/toggle-status - Toggling role status", roleId);

        try {
            UUID currentUserId = SecurityUtils.getCurrentUserId();

            // Récupérer le rôle actuel pour inverser son statut
            RoleDto currentRole = roleService.getRoleById(roleId);

            UpdateRoleDto updateDto = new UpdateRoleDto();
            updateDto.setIsActive(!Boolean.TRUE.equals(currentRole.getIsActive()));

            RoleDto updatedRole = roleService.updateRole(roleId, updateDto, currentUserId);

            String message = Boolean.TRUE.equals(updatedRole.getIsActive())
                ? "Rôle activé avec succès"
                : "Rôle désactivé avec succès";

            return ApiResponseUtil.success(updatedRole, message);
        } catch (IllegalArgumentException e) {
            log.warn("Role not found: {}", roleId);
            return ApiResponseUtil.notFound("Rôle non trouvé");
        } catch (IllegalStateException e) {
            log.warn("Cannot toggle role status: {}", e.getMessage());
            return ApiResponseUtil.forbidden(e.getMessage());
        } catch (Exception e) {
            log.error("Error toggling role status: {}", roleId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la modification du statut du rôle",
                500
            );
        }
    }

    @Operation(
        summary = "Cloner un rôle",
        description = "Crée une copie d'un rôle existant avec un nouveau nom"
    )
    @PostMapping("/{roleId}/clone")
    @PreAuthorize("hasAuthority('ROLE_WRITE')")
    public ResponseEntity<ApiResponse<RoleDto>> cloneRole(
        @Parameter(description = "ID du rôle à cloner")
        @PathVariable UUID roleId,
        @Parameter(description = "Nom du nouveau rôle")
        @RequestParam String newName,
        @Parameter(description = "ID de l'organisation de destination (optionnel)")
        @RequestParam(required = false) UUID targetOrganizationId
    ) {
        log.info("POST /roles/{}/clone - Cloning role with new name: {}", roleId, newName);

        try {
            // Récupérer le rôle original
            RoleDto originalRole = roleService.getRoleById(roleId);

            // Utiliser l'organisation courante si pas spécifiée
            UUID orgId = targetOrganizationId != null ? targetOrganizationId : originalRole.getOrganizationId();

            // Créer le nouveau rôle
            CreateRoleDto createDto = new CreateRoleDto();
            createDto.setName(newName);
            createDto.setDescription("Copie de: " + originalRole.getDescription());
            createDto.setOrganizationId(orgId);
            createDto.setRoleType(originalRole.getRoleType());
            createDto.setPermissions(originalRole.getPermissions());
            createDto.setPriority(originalRole.getPriority());
            createDto.setColor(originalRole.getColor());
            createDto.setIcon(originalRole.getIcon());
            createDto.setIsDefaultRole(false); // Les clones ne sont jamais des rôles par défaut

            UUID currentUserId = SecurityUtils.getCurrentUserId();
            RoleDto clonedRole = roleService.createRole(createDto, currentUserId);

            return ApiResponseUtil.created(
                clonedRole,
                "Rôle cloné avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Error cloning role: {}", e.getMessage());
            return ApiResponseUtil.badRequest(e.getMessage());
        } catch (Exception e) {
            log.error("Error cloning role: {}", roleId, e);
            return ApiResponseUtil.error(
                "Erreur lors du clonage du rôle",
                500
            );
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\AssignRoleDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO pour l'assignation d'un rôle à un utilisateur
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AssignRoleDto {

    @NotNull(message = "User ID is required")
    private UUID userId;

    @NotNull(message = "Role ID is required")
    private UUID roleId;

    @NotNull(message = "Organization ID is required")
    private UUID organizationId;

    private UUID agencyId; // Optionnel, pour les rôles limités à une agence

    private LocalDateTime expiresAt; // Optionnel, pour les assignations temporaires

    private String assignmentReason;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\BulkAssignRoleDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * DTO pour l'assignation en masse de rôles
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BulkAssignRoleDto {

    @NotEmpty(message = "User IDs list cannot be empty")
    private List<UUID> userIds;

    @NotNull(message = "Role ID is required")
    private UUID roleId;

    @NotNull(message = "Organization ID is required")
    private UUID organizationId;

    private UUID agencyId;
    private LocalDateTime expiresAt;
    private String assignmentReason;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\CreateRoleDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import inc.yowyob.rental_api.core.enums.RoleType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.util.Set;
import java.util.UUID;

/**
 * DTO pour la création d'un nouveau rôle
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateRoleDto {

    @NotBlank(message = "Role name is required")
    @Size(min = 2, max = 100, message = "Role name must be between 2 and 100 characters")
    private String name;

    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;

    @NotNull(message = "Organization ID is required")
    private UUID organizationId;

    private RoleType roleType;

    @Min(value = 0, message = "Priority must be positive")
    @Max(value = 100, message = "Priority must not exceed 100")
    private Integer priority = 0;

    private Set<String> permissions;

    @Pattern(regexp = "^#[0-9A-Fa-f]{6}$", message = "Color must be a valid hex color")
    private String color;

    private String icon;

    private Boolean isDefaultRole = false;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\PermissionDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO pour l'affichage des permissions
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PermissionDto {

    private String code;
    private String description;
    private String resource;
    private String category; // Calculé à partir du resource
    private Boolean isAssigned; // Indique si la permission est assignée au rôle courant
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\PermissionGroupDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * DTO pour grouper les permissions par ressource
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PermissionGroupDto {

    private String resource;
    private String resourceLabel;
    private String description;
    private List<PermissionDto> permissions;
    private Integer totalPermissions;
    private Integer assignedPermissions;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\RoleDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import inc.yowyob.rental_api.core.enums.RoleType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Set;
import java.util.UUID;

/**
 * DTO pour l'affichage des informations de rôle
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleDto {

    private UUID id;
    private String name;
    private String description;
    private UUID organizationId;
    private RoleType roleType;
    private Boolean isSystemRole;
    private Boolean isDefaultRole;
    private Boolean isActive;
    private Integer priority;
    private Set<String> permissions;
    private String color;
    private String icon;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private UUID createdBy;
    private UUID updatedBy;

    // Informations calculées
    private Integer permissionCount;
    private Integer userCount; // Nombre d'utilisateurs ayant ce rôle
    private String summary;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\RolePermissionsDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotNull;
import java.util.Set;
import java.util.UUID;

/**
 * DTO pour la mise à jour des permissions d'un rôle
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RolePermissionsDto {

    @NotNull(message = "Role ID is required")
    private UUID roleId;

    @NotNull(message = "Permissions are required")
    private Set<String> permissions;

    private String updateReason;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\RoleStatsDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * DTO pour les statistiques des rôles
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleStatsDto {

    private Long totalRoles;
    private Long activeRoles;
    private Long inactiveRoles;
    private Long systemRoles;
    private Long customRoles;
    private Long defaultRoles;

    private Long totalUserRoles;
    private Long activeUserRoles;
    private Long expiredUserRoles;
    private Long expiringSoonUserRoles;

    private LocalDateTime periodStart;
    private LocalDateTime periodEnd;

    // Statistiques par organisation
    private Long rolesCreatedThisPeriod;
    private Long rolesModifiedThisPeriod;
    private Long assignmentsThisPeriod;

    // Moyennes
    private Double averagePermissionsPerRole;
    private Double averageUsersPerRole;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\RoleTemplateDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import inc.yowyob.rental_api.core.enums.RoleType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

/**
 * DTO pour les templates de rôles prédéfinis
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleTemplateDto {

    private RoleType roleType;
    private String name;
    private String description;
    private Set<String> defaultPermissions;
    private Integer defaultPriority;
    private String defaultColor;
    private String defaultIcon;
    private Boolean isRecommended;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\UpdateRoleDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.util.Set;

/**
 * DTO pour la mise à jour d'un rôle
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UpdateRoleDto {

    @Size(min = 2, max = 100, message = "Role name must be between 2 and 100 characters")
    private String name;

    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;

    @Min(value = 0, message = "Priority must be positive")
    @Max(value = 100, message = "Priority must not exceed 100")
    private Integer priority;

    private Set<String> permissions;

    @Pattern(regexp = "^#[0-9A-Fa-f]{6}$", message = "Color must be a valid hex color")
    private String color;

    private String icon;

    private Boolean isDefaultRole;
    private Boolean isActive;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\UserPermissionsDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.Set;
import java.util.UUID;

/**
 * DTO pour l'affichage des permissions effectives d'un utilisateur
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserPermissionsDto {

    private UUID userId;
    private UUID organizationId;
    private Set<String> effectivePermissions;
    private List<RoleDto> assignedRoles;
    private List<PermissionGroupDto> permissionGroups;
    private Boolean hasFullAccess;
    private String accessLevel; // ADMIN, MANAGER, USER, LIMITED
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\dto\UserRoleDto.java ---

```java
package inc.yowyob.rental_api.role.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO pour l'affichage des assignations utilisateur-rôle
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRoleDto {

    private UUID id;
    private UUID userId;
    private UUID roleId;
    private UUID organizationId;
    private UUID agencyId;
    private LocalDateTime assignedAt;
    private LocalDateTime expiresAt;
    private Boolean isActive;
    private String assignmentReason;
    private UUID assignedBy;

    // Informations du rôle (dénormalisées pour l'affichage)
    private String roleName;
    private String roleDescription;
    private String roleColor;
    private String roleIcon;

    // Informations de l'utilisateur (dénormalisées pour l'affichage)
    private String userFullName;
    private String userEmail;

    // Informations calculées
    private Boolean isExpired;
    private Long daysUntilExpiration;
    private Boolean isExpiringSoon;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\entities\Role.java ---

```java
package inc.yowyob.rental_api.role.entities;

import inc.yowyob.rental_api.core.enums.RoleType;
import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

/**
 * Entité représentant un rôle dans le système
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Table("roles")
public class Role {

    @Id
    @PrimaryKey
    private UUID id;

    @NotBlank(message = "Role name is required")
    @Size(min = 2, max = 100, message = "Role name must be between 2 and 100 characters")
    private String name;

    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;

    @NotNull(message = "Organization ID is required")
    private UUID organizationId;

    // Type de rôle (prédéfini ou personnalisé)
    private RoleType roleType;

    // Indique si c'est un rôle système (non modifiable)
    private Boolean isSystemRole = false;

    // Indique si c'est un rôle par défaut pour les nouveaux utilisateurs
    private Boolean isDefaultRole = false;

    // Indique si le rôle est actif
    private Boolean isActive = true;

    // Priorité du rôle (plus le nombre est élevé, plus le rôle est prioritaire)
    private Integer priority = 0;

    // Permissions associées au rôle (stockées comme Set de codes de permission)
    private Set<String> permissions = new HashSet<>();

    // Métadonnées du rôle
    private String color; // Couleur pour l'affichage dans l'interface
    private String icon;  // Icône pour l'affichage

    // Audit
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private UUID createdBy;
    private UUID updatedBy;

    // Constructors
    public Role(String name, String description, UUID organizationId) {
        this.id = UUID.randomUUID();
        this.name = name;
        this.description = description;
        this.organizationId = organizationId;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    public Role(String name, String description, UUID organizationId, RoleType roleType) {
        this(name, description, organizationId);
        this.roleType = roleType;
        this.isSystemRole = roleType != null && roleType.isSystemRole();
    }

    /**
     * Ajoute une permission au rôle
     */
    public void addPermission(String permissionCode) {
        if (permissionCode != null && !permissionCode.trim().isEmpty()) {
            if (this.permissions == null) {
                this.permissions = new HashSet<>();
            }
            this.permissions.add(permissionCode.trim());
            this.updatedAt = LocalDateTime.now();
        }
    }

    /**
     * Retire une permission du rôle
     */
    public void removePermission(String permissionCode) {
        if (this.permissions != null && permissionCode != null) {
            this.permissions.remove(permissionCode.trim());
            this.updatedAt = LocalDateTime.now();
        }
    }

    /**
     * Vérifie si le rôle a une permission spécifique
     */
    public boolean hasPermission(String permissionCode) {
        return this.permissions != null && this.permissions.contains(permissionCode);
    }

    /**
     * Ajoute plusieurs permissions au rôle
     */
    public void addPermissions(Set<String> permissionCodes) {
        if (permissionCodes != null && !permissionCodes.isEmpty()) {
            if (this.permissions == null) {
                this.permissions = new HashSet<>();
            }
            this.permissions.addAll(permissionCodes);
            this.updatedAt = LocalDateTime.now();
        }
    }

    /**
     * Remplace toutes les permissions par une nouvelle liste
     */
    public void setPermissions(Set<String> permissionCodes) {
        this.permissions = permissionCodes != null ? new HashSet<>(permissionCodes) : new HashSet<>();
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Obtient le nombre de permissions
     */
    public int getPermissionCount() {
        return this.permissions != null ? this.permissions.size() : 0;
    }

    /**
     * Vérifie si le rôle peut être modifié
     */
    public boolean canBeModified() {
        return !Boolean.TRUE.equals(this.isSystemRole);
    }

    /**
     * Vérifie si le rôle peut être supprimé
     */
    public boolean canBeDeleted() {
        return !Boolean.TRUE.equals(this.isSystemRole) && !Boolean.TRUE.equals(this.isDefaultRole);
    }

    /**
     * Active le rôle
     */
    public void activate() {
        this.isActive = true;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Désactive le rôle
     */
    public void deactivate() {
        this.isActive = false;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Marque le rôle comme rôle par défaut
     */
    public void setAsDefault() {
        this.isDefaultRole = true;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Retire le statut de rôle par défaut
     */
    public void unsetAsDefault() {
        this.isDefaultRole = false;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Met à jour les métadonnées du rôle
     */
    public void updateMetadata(String color, String icon) {
        this.color = color;
        this.icon = icon;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Clone le rôle avec un nouveau nom
     */
    public Role cloneWithNewName(String newName, UUID newOrganizationId) {
        Role clonedRole = new Role(newName, this.description, newOrganizationId);
        clonedRole.setPermissions(new HashSet<>(this.permissions));
        clonedRole.setPriority(this.priority);
        clonedRole.setColor(this.color);
        clonedRole.setIcon(this.icon);
        return clonedRole;
    }

    /**
     * Vérifie si le rôle est équivalent à un autre (mêmes permissions)
     */
    public boolean isEquivalentTo(Role otherRole) {
        if (otherRole == null) return false;
        Set<String> thisPermissions = this.permissions != null ? this.permissions : new HashSet<>();
        Set<String> otherPermissions = otherRole.permissions != null ? otherRole.permissions : new HashSet<>();
        return thisPermissions.equals(otherPermissions);
    }

    /**
     * Obtient un résumé du rôle
     */
    public String getSummary() {
        StringBuilder summary = new StringBuilder();
        summary.append("Rôle: ").append(this.name);
        if (this.roleType != null) {
            summary.append(" (").append(this.roleType.getDescription()).append(")");
        }
        summary.append(" - ").append(getPermissionCount()).append(" permission(s)");
        if (Boolean.TRUE.equals(this.isSystemRole)) {
            summary.append(" [SYSTÈME]");
        }
        if (Boolean.TRUE.equals(this.isDefaultRole)) {
            summary.append(" [DÉFAUT]");
        }
        if (!Boolean.TRUE.equals(this.isActive)) {
            summary.append(" [INACTIF]");
        }
        return summary.toString();
    }

    public void setName(String name) {
        if (name != null) {
            this.name = name.trim();
            this.updatedAt = LocalDateTime.now();
        }
    }

    public void setDescription(String description) {
        this.description = description != null ? description.trim() : null;
        this.updatedAt = LocalDateTime.now();
    }

    public void setPriority(Integer priority) {
        this.priority = priority != null ? Math.max(0, priority) : 0;
        this.updatedAt = LocalDateTime.now();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\entities\UserRole.java ---

```java
package inc.yowyob.rental_api.role.entities;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Entité d'association entre utilisateur et rôle
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Table("user_roles")
public class UserRole {

    @Id
    @PrimaryKey
    private UUID id;

    @NotNull(message = "User ID is required")
    private UUID userId;

    @NotNull(message = "Role ID is required")
    private UUID roleId;

    @NotNull(message = "Organization ID is required")
    private UUID organizationId;

    // Agence spécifique (optionnel, pour les rôles limités à une agence)
    private UUID agencyId;

    // Date d'assignation du rôle
    private LocalDateTime assignedAt;

    // Date d'expiration du rôle (optionnel)
    private LocalDateTime expiresAt;

    // Indique si l'assignation est active
    private Boolean isActive = true;

    // Raison de l'assignation
    private String assignmentReason;

    // Audit
    private UUID assignedBy;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // Constructors
    public UserRole(UUID userId, UUID roleId, UUID organizationId) {
        this.id = UUID.randomUUID();
        this.userId = userId;
        this.roleId = roleId;
        this.organizationId = organizationId;
        this.assignedAt = LocalDateTime.now();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    public UserRole(UUID userId, UUID roleId, UUID organizationId, UUID agencyId) {
        this(userId, roleId, organizationId);
        this.agencyId = agencyId;
    }

    /**
     * Vérifie si l'assignation est encore valide
     */
    public boolean isValid() {
        LocalDateTime now = LocalDateTime.now();
        return Boolean.TRUE.equals(this.isActive) &&
            (this.expiresAt == null || now.isBefore(this.expiresAt));
    }

    /**
     * Vérifie si l'assignation a expiré
     */
    public boolean isExpired() {
        return this.expiresAt != null && LocalDateTime.now().isAfter(this.expiresAt);
    }

    /**
     * Définit une date d'expiration
     */
    public void setExpiration(LocalDateTime expiresAt) {
        this.expiresAt = expiresAt;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Prolonge l'assignation
     */
    public void extend(int days) {
        if (this.expiresAt != null) {
            this.expiresAt = this.expiresAt.plusDays(days);
        } else {
            this.expiresAt = LocalDateTime.now().plusDays(days);
        }
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Révoque l'assignation du rôle
     */
    public void revoke() {
        this.isActive = false;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Réactive l'assignation du rôle
     */
    public void reactivate() {
        this.isActive = true;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Vérifie si l'assignation est limitée à une agence
     */
    public boolean isAgencySpecific() {
        return this.agencyId != null;
    }

    /**
     * Obtient le nombre de jours restants avant expiration
     */
    public long getDaysUntilExpiration() {
        if (this.expiresAt == null) {
            return Long.MAX_VALUE; // Pas d'expiration
        }
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDateTime.now(), this.expiresAt);
    }

    /**
     * Vérifie si l'assignation expire bientôt
     */
    public boolean isExpiringSoon(int days) {
        long daysUntilExpiration = getDaysUntilExpiration();
        return daysUntilExpiration <= days && daysUntilExpiration > 0;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\repository\RoleRepository.java ---

```java
package inc.yowyob.rental_api.role.repository;

import inc.yowyob.rental_api.core.enums.RoleType;
import inc.yowyob.rental_api.role.entities.Role;
import org.springframework.data.cassandra.repository.CassandraRepository;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface RoleRepository extends CassandraRepository<Role, UUID> {

    /**
     * Trouve tous les rôles d'une organisation
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 ALLOW FILTERING")
    List<Role> findByOrganizationId(UUID organizationId);

    /**
     * Trouve les rôles actifs d'une organisation
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    List<Role> findActiveByOrganizationId(UUID organizationId);

    /**
     * Trouve un rôle par nom dans une organisation
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND name = ?1 ALLOW FILTERING")
    Optional<Role> findByOrganizationIdAndName(UUID organizationId, String name);

    /**
     * Trouve les rôles par type
     */
    @Query("SELECT * FROM roles WHERE role_type = ?0 ALLOW FILTERING")
    List<Role> findByRoleType(String roleType);

    /**
     * Trouve les rôles système
     */
    @Query("SELECT * FROM roles WHERE issystemrole = true ALLOW FILTERING")
    List<Role> findSystemRoles();

    /**
     * Trouve les rôles par défaut d'une organisation
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND is_default_role = true ALLOW FILTERING")
    List<Role> findDefaultRolesByOrganizationId(UUID organizationId);

    /**
     * Trouve les rôles personnalisés (non-système) d'une organisation
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND is_system_role = false ALLOW FILTERING")
    List<Role> findCustomRolesByOrganizationId(UUID organizationId);

    /**
     * Trouve les rôles créés par un utilisateur spécifique
     */
    @Query("SELECT * FROM roles WHERE created_by = ?0 ALLOW FILTERING")
    List<Role> findByCreatedBy(UUID createdBy);

    /**
     * Trouve les rôles créés dans une période donnée
     */
    @Query("SELECT * FROM roles WHERE created_at >= ?0 AND created_at <= ?1 ALLOW FILTERING")
    List<Role> findByCreatedAtBetween(LocalDateTime startDate, LocalDateTime endDate);

    /**
     * Trouve les rôles avec une priorité supérieure ou égale
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND priority >= ?1 ALLOW FILTERING")
    List<Role> findByOrganizationIdAndPriorityGreaterThanEqual(UUID organizationId, Integer priority);

    /**
     * Trouve les rôles contenant une permission spécifique
     */
    @Query("SELECT * FROM roles WHERE permissions CONTAINS ?0 ALLOW FILTERING")
    List<Role> findByPermission(String permission);

    /**
     * Trouve les rôles d'une organisation contenant une permission spécifique
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND permissions CONTAINS ?1 ALLOW FILTERING")
    List<Role> findByOrganizationIdAndPermission(UUID organizationId, String permission);

    /**
     * Compte les rôles actifs d'une organisation
     */
    @Query("SELECT COUNT(*) FROM roles WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    Long countActiveByOrganizationId(UUID organizationId);

    /**
     * Comte les rôles par type
     */
    @Query("SELECT COUNT(*) FROM roles WHERE role_type = ?0 ALLOW FILTERING")
    Long countByRoleType(String roleType);

    /**
     * Trouve les rôles avec des couleurs spécifiques
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND color = ?1 ALLOW FILTERING")
    List<Role> findByOrganizationIdAndColor(UUID organizationId, String color);

    /**
     * Vérifie si un nom de rôle existe déjà dans une organisation
     */
    @Query("SELECT COUNT(*) FROM roles WHERE organization_id = ?0 AND name = ?1 ALLOW FILTERING")
    Long countByOrganizationIdAndName(UUID organizationId, String name);

    /**
     * Méthode par défaut pour vérifier l'existence d'un nom de rôle
     */
    default boolean existsByOrganizationIdAndName(UUID organizationId, String name) {
        return countByOrganizationIdAndName(organizationId, name) > 0;
    }

    /**
     * Trouve les rôles modifiés récemment
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND updated_at >= ?1 ALLOW FILTERING")
    List<Role> findRecentlyUpdatedByOrganizationId(UUID organizationId, LocalDateTime since);

    /**
     * Trouve les rôles inactifs d'une organisation
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND is_active = false ALLOW FILTERING")
    List<Role> findInactiveByOrganizationId(UUID organizationId);
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\repository\UserRoleRepository.java ---

```java
package inc.yowyob.rental_api.role.repository;

import inc.yowyob.rental_api.role.entities.UserRole;
import org.springframework.data.cassandra.repository.CassandraRepository;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface UserRoleRepository extends CassandraRepository<UserRole, UUID> {

    /**
     * Trouve tous les rôles d'un utilisateur
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 ALLOW FILTERING")
    List<UserRole> findByUserId(UUID userId);

    /**
     * Trouve les rôles actifs d'un utilisateur
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND is_active = true ALLOW FILTERING")
    List<UserRole> findActiveByUserId(UUID userId);

    /**
     * Trouve les rôles valides d'un utilisateur (actifs et non expirés)
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND is_active = true AND (expires_at IS NULL OR expires_at > ?1) ALLOW FILTERING")
    List<UserRole> findValidByUserId(UUID userId, LocalDateTime now);

    /**
     * Trouve les utilisateurs ayant un rôle spécifique
     */
    @Query("SELECT * FROM user_roles WHERE role_id = ?0 AND is_active = true ALLOW FILTERING")
    List<UserRole> findActiveByRoleId(UUID roleId);

    /**
     * Trouve les rôles d'un utilisateur dans une organisation
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND organization_id = ?1 ALLOW FILTERING")
    List<UserRole> findByUserIdAndOrganizationId(UUID userId, UUID organizationId);

    /**
     * Trouve les rôles actifs d'un utilisateur dans une organisation
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND organization_id = ?1 AND is_active = true ALLOW FILTERING")
    List<UserRole> findActiveByUserIdAndOrganizationId(UUID userId, UUID organizationId);

    /**
     * Trouve une assignation spécifique utilisateur-rôle
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND role_id = ?1 ALLOW FILTERING")
    Optional<UserRole> findByUserIdAndRoleId(UUID userId, UUID roleId);

    /**
     * Trouve une assignation active spécifique utilisateur-rôle
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND role_id = ?1 AND is_active = true ALLOW FILTERING")
    Optional<UserRole> findActiveByUserIdAndRoleId(UUID userId, UUID roleId);

    /**
     * Trouve les rôles d'un utilisateur dans une agence spécifique
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND agency_id = ?1 AND is_active = true ALLOW FILTERING")
    List<UserRole> findActiveByUserIdAndAgencyId(UUID userId, UUID agencyId);

    /**
     * Trouve tous les utilisateurs d'une organisation avec leurs rôles
     */
    @Query("SELECT * FROM user_roles WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    List<UserRole> findActiveByOrganizationId(UUID organizationId);

    /**
     * Trouve tous les utilisateurs d'une agence avec leurs rôles
     */
    @Query("SELECT * FROM user_roles WHERE agency_id = ?0 AND is_active = true ALLOW FILTERING")
    List<UserRole> findActiveByAgencyId(UUID agencyId);

    /**
     * Trouve les assignations qui expirent bientôt
     */
    @Query("SELECT * FROM user_roles WHERE is_active = true AND expires_at IS NOT NULL AND expires_at <= ?0 AND expires_at > ?1 ALLOW FILTERING")
    List<UserRole> findExpiringSoon(LocalDateTime expirationThreshold, LocalDateTime now);

    /**
     * Trouve les assignations expirées
     */
    @Query("SELECT * FROM user_roles WHERE is_active = true AND expires_at IS NOT NULL AND expires_at < ?0 ALLOW FILTERING")
    List<UserRole> findExpired(LocalDateTime now);

    /**
     * Trouve les assignations créées par un utilisateur spécifique
     */
    @Query("SELECT * FROM user_roles WHERE assigned_by = ?0 ALLOW FILTERING")
    List<UserRole> findByAssignedBy(UUID assignedBy);

    /**
     * Trouve les assignations dans une période donnée
     */
    @Query("SELECT * FROM user_roles WHERE assigned_at >= ?0 AND assigned_at <= ?1 ALLOW FILTERING")
    List<UserRole> findByAssignedAtBetween(LocalDateTime startDate, LocalDateTime endDate);

    /**
     * Compte les utilisateurs ayant un rôle spécifique
     */
    @Query("SELECT COUNT(*) FROM user_roles WHERE role_id = ?0 AND is_active = true ALLOW FILTERING")
    Long countActiveByRoleId(UUID roleId);

    /**
     * Compte les rôles actifs d'un utilisateur
     */
    @Query("SELECT COUNT(*) FROM user_roles WHERE user_id = ?0 AND is_active = true ALLOW FILTERING")
    Long countActiveByUserId(UUID userId);

    /**
     * Compte les utilisateurs actifs dans une organisation
     */
    @Query("SELECT COUNT(DISTINCT user_id) FROM user_roles WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    Long countDistinctActiveUsersByOrganizationId(UUID organizationId);

    /**
     * Trouve les assignations temporaires (avec date d'expiration)
     */
    @Query("SELECT * FROM user_roles WHERE expires_at IS NOT NULL AND is_active = true ALLOW FILTERING")
    List<UserRole> findTemporaryAssignments();

    /**
     * Trouve les assignations permanentes (sans date d'expiration)
     */
    @Query("SELECT * FROM user_roles WHERE expires_at IS NULL AND is_active = true ALLOW FILTERING")
    List<UserRole> findPermanentAssignments();

    /**
     * Trouve les rôles révoqués (inactifs)
     */
    @Query("SELECT * FROM user_roles WHERE is_active = false ALLOW FILTERING")
    List<UserRole> findRevokedAssignments();

    /**
     * Trouve les assignations par organisation et rôle
     */
    @Query("SELECT * FROM user_roles WHERE organization_id = ?0 AND role_id = ?1 AND is_active = true ALLOW FILTERING")
    List<UserRole> findActiveByOrganizationIdAndRoleId(UUID organizationId, UUID roleId);

    /**
     * Vérifie si un utilisateur a un rôle spécifique actif
     */
    @Query("SELECT COUNT(*) FROM user_roles WHERE user_id = ?0 AND role_id = ?1 AND is_active = true ALLOW FILTERING")
    Long countActiveByUserIdAndRoleId(UUID userId, UUID roleId);

    /**
     * Méthode par défaut pour vérifier si un utilisateur a un rôle actif
     */
    default boolean hasActiveRole(UUID userId, UUID roleId) {
        return countActiveByUserIdAndRoleId(userId, roleId) > 0;
    }

    /**
     * Trouve les assignations récentes
     */
    @Query("SELECT * FROM user_roles WHERE assigned_at >= ?0 ALLOW FILTERING")
    List<UserRole> findRecentAssignments(LocalDateTime since);

    /**
     * Trouve les assignations par raison d'assignation
     */
    @Query("SELECT * FROM user_roles WHERE assignment_reason = ?0 ALLOW FILTERING")
    List<UserRole> findByAssignmentReason(String reason);
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\role\service\RoleService.java ---

```java
package inc.yowyob.rental_api.role.service;

import inc.yowyob.rental_api.core.enums.Permission;
import inc.yowyob.rental_api.core.enums.RoleType;
import inc.yowyob.rental_api.role.dto.*;
import inc.yowyob.rental_api.role.entities.Role;
import inc.yowyob.rental_api.role.entities.UserRole;
import inc.yowyob.rental_api.role.repository.RoleRepository;
import inc.yowyob.rental_api.role.repository.UserRoleRepository;
import inc.yowyob.rental_api.user.entities.User;
import inc.yowyob.rental_api.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class RoleService {

    private final RoleRepository roleRepository;
    private final UserRoleRepository userRoleRepository;
    private final UserRepository userRepository;

    /**
     * Crée un nouveau rôle
     */
    @Transactional
    public RoleDto createRole(CreateRoleDto createRoleDto, UUID createdBy) {
        log.info("Creating new role: {} for organization: {}", createRoleDto.getName(), createRoleDto.getOrganizationId());

        // Vérifier que le nom n'existe pas déjà dans l'organisation
        if (roleRepository.existsByOrganizationIdAndName(createRoleDto.getOrganizationId(), createRoleDto.getName())) {
            throw new IllegalArgumentException("A role with this name already exists in the organization");
        }

        // Valider les permissions
        validatePermissions(createRoleDto.getPermissions());

        // Créer le rôle
        Role role = new Role(
            createRoleDto.getName(),
            createRoleDto.getDescription(),
            createRoleDto.getOrganizationId(),
            createRoleDto.getRoleType()
        );

        role.setPriority(createRoleDto.getPriority());
        role.setPermissions(createRoleDto.getPermissions() != null ? new HashSet<>(createRoleDto.getPermissions()) : new HashSet<>());
        role.setColor(createRoleDto.getColor());
        role.setIcon(createRoleDto.getIcon());
        role.setIsDefaultRole(createRoleDto.getIsDefaultRole());
        role.setCreatedBy(createdBy);
        role.setUpdatedBy(createdBy);

        Role savedRole = roleRepository.save(role);
        log.info("Role created successfully with ID: {}", savedRole.getId());

        return mapToRoleDto(savedRole);
    }

    /**
     * Met à jour un rôle existant
     */
    @Transactional
    public RoleDto updateRole(UUID roleId, UpdateRoleDto updateRoleDto, UUID updatedBy) {
        log.info("Updating role: {}", roleId);

        Role role = getRoleOrThrow(roleId);

        // Vérifier que le rôle peut être modifié
        if (!role.canBeModified()) {
            throw new IllegalStateException("System roles cannot be modified");
        }

        // Vérifier le nom unique si changé
        if (updateRoleDto.getName() != null && !updateRoleDto.getName().equals(role.getName())) {
            if (roleRepository.existsByOrganizationIdAndName(role.getOrganizationId(), updateRoleDto.getName())) {
                throw new IllegalArgumentException("A role with this name already exists in the organization");
            }
            role.setName(updateRoleDto.getName());
        }

        // Mettre à jour les autres champs
        if (updateRoleDto.getDescription() != null) {
            role.setDescription(updateRoleDto.getDescription());
        }
        if (updateRoleDto.getPriority() != null) {
            role.setPriority(updateRoleDto.getPriority());
        }
        if (updateRoleDto.getPermissions() != null) {
            validatePermissions(updateRoleDto.getPermissions());
            role.setPermissions(new HashSet<>(updateRoleDto.getPermissions()));
        }
        if (updateRoleDto.getColor() != null) {
            role.setColor(updateRoleDto.getColor());
        }
        if (updateRoleDto.getIcon() != null) {
            role.setIcon(updateRoleDto.getIcon());
        }
        if (updateRoleDto.getIsDefaultRole() != null) {
            role.setIsDefaultRole(updateRoleDto.getIsDefaultRole());
        }
        if (updateRoleDto.getIsActive() != null) {
            role.setIsActive(updateRoleDto.getIsActive());
        }

        role.setUpdatedBy(updatedBy);
        role.setUpdatedAt(LocalDateTime.now());

        Role savedRole = roleRepository.save(role);
        log.info("Role updated successfully: {}", roleId);

        return mapToRoleDto(savedRole);
    }

    /**
     * Supprime un rôle
     */
    @Transactional
    public void deleteRole(UUID roleId) {
        log.info("Deleting role: {}", roleId);

        Role role = getRoleOrThrow(roleId);

        // Vérifier que le rôle peut être supprimé
        if (!role.canBeDeleted()) {
            throw new IllegalStateException("System roles or default roles cannot be deleted");
        }

        // Vérifier qu'aucun utilisateur n'a ce rôle
        Long userCount = userRoleRepository.countActiveByRoleId(roleId);
        if (userCount > 0) {
            throw new IllegalStateException("Cannot delete role that is assigned to users. Remove all assignments first.");
        }

        roleRepository.delete(role);
        log.info("Role deleted successfully: {}", roleId);
    }

    /**
     * Récupère un rôle par ID
     */
    public RoleDto getRoleById(UUID roleId) {
        log.debug("Fetching role: {}", roleId);
        Role role = getRoleOrThrow(roleId);
        return mapToRoleDto(role);
    }

    /**
     * Récupère tous les rôles d'une organisation
     */
    public List<RoleDto> getRolesByOrganizationId(UUID organizationId) {
        log.debug("Fetching roles for organization: {}", organizationId);
        List<Role> roles = roleRepository.findByOrganizationId(organizationId);
        return roles.stream()
            .map(this::mapToRoleDto)
            .collect(Collectors.toList());
    }

    /**
     * Récupère les rôles actifs d'une organisation
     */
    public List<RoleDto> getActiveRolesByOrganizationId(UUID organizationId) {
        log.debug("Fetching active roles for organization: {}", organizationId);
        List<Role> roles = roleRepository.findActiveByOrganizationId(organizationId);
        return roles.stream()
            .map(this::mapToRoleDto)
            .collect(Collectors.toList());
    }

    /**
     * Assigne un rôle à un utilisateur
     */
    @Transactional
    public UserRoleDto assignRole(AssignRoleDto assignRoleDto, UUID assignedBy) {
        log.info("Assigning role {} to user {} in organization {}",
            assignRoleDto.getRoleId(), assignRoleDto.getUserId(), assignRoleDto.getOrganizationId());

        // Vérifier que l'utilisateur existe
        User user = userRepository.findById(assignRoleDto.getUserId())
            .orElseThrow(() -> new IllegalArgumentException("User not found"));

        // Vérifier que le rôle existe
        Role role = getRoleOrThrow(assignRoleDto.getRoleId());

        // Vérifier que le rôle appartient à la même organisation
        if (!role.getOrganizationId().equals(assignRoleDto.getOrganizationId())) {
            throw new IllegalArgumentException("Role does not belong to the specified organization");
        }

        // Vérifier si l'utilisateur a déjà ce rôle actif
        if (userRoleRepository.hasActiveRole(assignRoleDto.getUserId(), assignRoleDto.getRoleId())) {
            throw new IllegalStateException("User already has this role assigned");
        }

        // Créer l'assignation
        UserRole userRole = new UserRole(
            assignRoleDto.getUserId(),
            assignRoleDto.getRoleId(),
            assignRoleDto.getOrganizationId(),
            assignRoleDto.getAgencyId()
        );

        userRole.setExpiresAt(assignRoleDto.getExpiresAt());
        userRole.setAssignmentReason(assignRoleDto.getAssignmentReason());
        userRole.setAssignedBy(assignedBy);

        UserRole savedUserRole = userRoleRepository.save(userRole);
        log.info("Role assigned successfully: {}", savedUserRole.getId());

        return mapToUserRoleDto(savedUserRole, role, user);
    }

    /**
     * Révoque un rôle d'un utilisateur
     */
    @Transactional
    public void revokeRole(UUID userId, UUID roleId) {
        log.info("Revoking role {} from user {}", roleId, userId);

        UserRole userRole = userRoleRepository.findActiveByUserIdAndRoleId(userId, roleId)
            .orElseThrow(() -> new IllegalArgumentException("Active role assignment not found"));

        userRole.revoke();
        userRoleRepository.save(userRole);

        log.info("Role revoked successfully");
    }

    /**
     * Assigne des rôles en masse
     */
    @Transactional
    public List<UserRoleDto> bulkAssignRole(BulkAssignRoleDto bulkAssignRoleDto, UUID assignedBy) {
        log.info("Bulk assigning role {} to {} users", bulkAssignRoleDto.getRoleId(), bulkAssignRoleDto.getUserIds().size());

        // Vérifier que le rôle existe
        Role role = getRoleOrThrow(bulkAssignRoleDto.getRoleId());

        List<UserRoleDto> results = new ArrayList<>();

        for (UUID userId : bulkAssignRoleDto.getUserIds()) {
            try {
                // Vérifier que l'utilisateur existe
                User user = userRepository.findById(userId)
                    .orElseThrow(() -> new IllegalArgumentException("User not found: " + userId));

                // Vérifier si l'utilisateur n'a pas déjà ce rôle
                if (!userRoleRepository.hasActiveRole(userId, bulkAssignRoleDto.getRoleId())) {
                    UserRole userRole = new UserRole(
                        userId,
                        bulkAssignRoleDto.getRoleId(),
                        bulkAssignRoleDto.getOrganizationId(),
                        bulkAssignRoleDto.getAgencyId()
                    );

                    userRole.setExpiresAt(bulkAssignRoleDto.getExpiresAt());
                    userRole.setAssignmentReason(bulkAssignRoleDto.getAssignmentReason());
                    userRole.setAssignedBy(assignedBy);

                    UserRole savedUserRole = userRoleRepository.save(userRole);
                    results.add(mapToUserRoleDto(savedUserRole, role, user));
                }
            } catch (Exception e) {
                log.error("Error assigning role to user {}: {}", userId, e.getMessage());
                // Continue with other users
            }
        }

        log.info("Bulk assignment completed: {} assignments created", results.size());
        return results;
    }

    /**
     * Récupère les rôles d'un utilisateur
     */
    public List<UserRoleDto> getUserRoles(UUID userId) {
        log.debug("Fetching roles for user: {}", userId);

        List<UserRole> userRoles = userRoleRepository.findActiveByUserId(userId);
        List<UserRoleDto> result = new ArrayList<>();

        for (UserRole userRole : userRoles) {
            try {
                Role role = roleRepository.findById(userRole.getRoleId()).orElse(null);
                User user = userRepository.findById(userRole.getUserId()).orElse(null);
                if (role != null && user != null) {
                    result.add(mapToUserRoleDto(userRole, role, user));
                }
            } catch (Exception e) {
                log.error("Error mapping user role {}: {}", userRole.getId(), e.getMessage());
            }
        }

        return result;
    }

    /**
     * Récupère les permissions effectives d'un utilisateur
     */
    public UserPermissionsDto getUserEffectivePermissions(UUID userId, UUID organizationId) {
        log.debug("Calculating effective permissions for user {} in organization {}", userId, organizationId);

        List<UserRole> userRoles = userRoleRepository.findValidByUserId(userId, LocalDateTime.now());
        Set<String> effectivePermissions = new HashSet<>();
        List<RoleDto> assignedRoles = new ArrayList<>();

        for (UserRole userRole : userRoles) {
            if (userRole.getOrganizationId().equals(organizationId)) {
                try {
                    Role role = roleRepository.findById(userRole.getRoleId()).orElse(null);
                    if (role != null && Boolean.TRUE.equals(role.getIsActive())) {
                        effectivePermissions.addAll(role.getPermissions());
                        assignedRoles.add(mapToRoleDto(role));
                    }
                } catch (Exception e) {
                    log.error("Error processing role {}: {}", userRole.getRoleId(), e.getMessage());
                }
            }
        }

        // Grouper les permissions par ressource
        List<PermissionGroupDto> permissionGroups = groupPermissionsByResource(effectivePermissions);

        // Déterminer le niveau d'accès
        String accessLevel = determineAccessLevel(effectivePermissions);
        boolean hasFullAccess = effectivePermissions.contains(Permission.SYSTEM_ADMIN.getCode());

        return UserPermissionsDto.builder()
            .userId(userId)
            .organizationId(organizationId)
            .effectivePermissions(effectivePermissions)
            .assignedRoles(assignedRoles)
            .permissionGroups(permissionGroups)
            .hasFullAccess(hasFullAccess)
            .accessLevel(accessLevel)
            .build();
    }

    /**
     * Met à jour les permissions d'un rôle
     */
    @Transactional
    public RoleDto updateRolePermissions(RolePermissionsDto rolePermissionsDto, UUID updatedBy) {
        log.info("Updating permissions for role: {}", rolePermissionsDto.getRoleId());

        Role role = getRoleOrThrow(rolePermissionsDto.getRoleId());

        // Vérifier que le rôle peut être modifié
        if (!role.canBeModified()) {
            throw new IllegalStateException("System roles cannot be modified");
        }

        // Valider les permissions
        validatePermissions(rolePermissionsDto.getPermissions());

        // Mettre à jour les permissions
        role.setPermissions(new HashSet<>(rolePermissionsDto.getPermissions()));
        role.setUpdatedBy(updatedBy);
        role.setUpdatedAt(LocalDateTime.now());

        Role savedRole = roleRepository.save(role);
        log.info("Role permissions updated successfully");

        return mapToRoleDto(savedRole);
    }

    /**
     * Récupère toutes les permissions disponibles groupées par ressource
     */
    public List<PermissionGroupDto> getAllPermissionsGrouped() {
        log.debug("Fetching all permissions grouped by resource");

        Map<String, List<Permission>> permissionsByResource = Arrays.stream(Permission.values())
            .collect(Collectors.groupingBy(Permission::getResource));

        return permissionsByResource.entrySet().stream()
            .map(entry -> {
                String resource = entry.getKey();
                List<Permission> permissions = entry.getValue();

                List<PermissionDto> permissionDtos = permissions.stream()
                    .map(permission -> PermissionDto.builder()
                        .code(permission.getCode())
                        .description(permission.getDescription())
                        .resource(permission.getResource())
                        .category(permission.getResource())
                        .isAssigned(false)
                        .build())
                    .collect(Collectors.toList());

                return PermissionGroupDto.builder()
                    .resource(resource)
                    .resourceLabel(getResourceLabel(resource))
                    .description(getResourceDescription(resource))
                    .permissions(permissionDtos)
                    .totalPermissions(permissions.size())
                    .assignedPermissions(0)
                    .build();
            })
            .sorted(Comparator.comparing(PermissionGroupDto::getResourceLabel))
            .collect(Collectors.toList());
    }

    /**
     * Récupère les statistiques des rôles pour une organisation
     */
    public RoleStatsDto getRoleStats(UUID organizationId) {
        log.debug("Calculating role statistics for organization: {}", organizationId);

        List<Role> allRoles = roleRepository.findByOrganizationId(organizationId);
        List<UserRole> allUserRoles = userRoleRepository.findActiveByOrganizationId(organizationId);

        LocalDateTime now = LocalDateTime.now();
        LocalDateTime thirtyDaysAgo = now.minusDays(30);

        long totalRoles = allRoles.size();
        long activeRoles = allRoles.stream().mapToLong(role -> Boolean.TRUE.equals(role.getIsActive()) ? 1 : 0).sum();
        long inactiveRoles = totalRoles - activeRoles;
        long systemRoles = allRoles.stream().mapToLong(role -> Boolean.TRUE.equals(role.getIsSystemRole()) ? 1 : 0).sum();
        long customRoles = totalRoles - systemRoles;
        long defaultRoles = allRoles.stream().mapToLong(role -> Boolean.TRUE.equals(role.getIsDefaultRole()) ? 1 : 0).sum();

        long totalUserRoles = allUserRoles.size();
        long expiredUserRoles = allUserRoles.stream()
            .mapToLong(ur -> ur.isExpired() ? 1 : 0).sum();
        long expiringSoonUserRoles = allUserRoles.stream()
            .mapToLong(ur -> ur.isExpiringSoon(7) ? 1 : 0).sum();

        long rolesCreatedThisPeriod = allRoles.stream()
            .mapToLong(role -> role.getCreatedAt().isAfter(thirtyDaysAgo) ? 1 : 0).sum();

        double averagePermissionsPerRole = allRoles.stream()
            .mapToInt(role -> role.getPermissions() != null ? role.getPermissions().size() : 0)
            .average().orElse(0.0);

        return RoleStatsDto.builder()
            .totalRoles(totalRoles)
            .activeRoles(activeRoles)
            .inactiveRoles(inactiveRoles)
            .systemRoles(systemRoles)
            .customRoles(customRoles)
            .defaultRoles(defaultRoles)
            .totalUserRoles(totalUserRoles)
            .activeUserRoles(totalUserRoles - expiredUserRoles)
            .expiredUserRoles(expiredUserRoles)
            .expiringSoonUserRoles(expiringSoonUserRoles)
            .periodStart(thirtyDaysAgo)
            .periodEnd(now)
            .rolesCreatedThisPeriod(rolesCreatedThisPeriod)
            .averagePermissionsPerRole(averagePermissionsPerRole)
            .build();
    }

    /**
     * Nettoie les assignations expirées
     */
    @Transactional
    public void cleanupExpiredAssignments() {
        log.info("Cleaning up expired role assignments");

        List<UserRole> expiredAssignments = userRoleRepository.findExpired(LocalDateTime.now());

        for (UserRole userRole : expiredAssignments) {
            userRole.revoke();
            userRoleRepository.save(userRole);
        }

        log.info("Cleaned up {} expired role assignments", expiredAssignments.size());
    }

    /**
     * Crée des rôles par défaut pour une nouvelle organisation
     */
    @Transactional
    public List<RoleDto> createDefaultRoles(UUID organizationId, UUID createdBy) {
        log.info("Creating default roles for organization: {}", organizationId);

        List<RoleTemplateDto> templates = getDefaultRoleTemplates();
        List<RoleDto> createdRoles = new ArrayList<>();

        for (RoleTemplateDto template : templates) {
            try {
                CreateRoleDto createRoleDto = new CreateRoleDto();
                createRoleDto.setName(template.getName());
                createRoleDto.setDescription(template.getDescription());
                createRoleDto.setOrganizationId(organizationId);
                createRoleDto.setRoleType(template.getRoleType());
                createRoleDto.setPermissions(template.getDefaultPermissions());
                createRoleDto.setPriority(template.getDefaultPriority());
                createRoleDto.setColor(template.getDefaultColor());
                createRoleDto.setIcon(template.getDefaultIcon());
                createRoleDto.setIsDefaultRole(true);

                RoleDto createdRole = createRole(createRoleDto, createdBy);
                createdRoles.add(createdRole);
            } catch (Exception e) {
                log.error("Error creating default role {}: {}", template.getName(), e.getMessage());
            }
        }

        log.info("Created {} default roles for organization: {}", createdRoles.size(), organizationId);
        return createdRoles;
    }

    // ==================== MÉTHODES PRIVÉES ====================

    private Role getRoleOrThrow(UUID roleId) {
        return roleRepository.findById(roleId)
            .orElseThrow(() -> new IllegalArgumentException("Role not found: " + roleId));
    }

    private void validatePermissions(Set<String> permissions) {
        if (permissions == null) return;

        Set<String> validPermissions = Arrays.stream(Permission.values())
            .map(Permission::getCode)
            .collect(Collectors.toSet());

        for (String permission : permissions) {
            if (!validPermissions.contains(permission)) {
                throw new IllegalArgumentException("Invalid permission: " + permission);
            }
        }
    }

    private RoleDto mapToRoleDto(Role role) {
        Long userCount = userRoleRepository.countActiveByRoleId(role.getId());

        return RoleDto.builder()
            .id(role.getId())
            .name(role.getName())
            .description(role.getDescription())
            .organizationId(role.getOrganizationId())
            .roleType(role.getRoleType())
            .isSystemRole(role.getIsSystemRole())
            .isDefaultRole(role.getIsDefaultRole())
            .isActive(role.getIsActive())
            .priority(role.getPriority())
            .permissions(role.getPermissions())
            .color(role.getColor())
            .icon(role.getIcon())
            .createdAt(role.getCreatedAt())
            .updatedAt(role.getUpdatedAt())
            .createdBy(role.getCreatedBy())
            .updatedBy(role.getUpdatedBy())
            .permissionCount(role.getPermissionCount())
            .userCount(userCount.intValue())
            .summary(role.getSummary())
            .build();
    }

    private UserRoleDto mapToUserRoleDto(UserRole userRole, Role role, User user) {
        return UserRoleDto.builder()
            .id(userRole.getId())
            .userId(userRole.getUserId())
            .roleId(userRole.getRoleId())
            .organizationId(userRole.getOrganizationId())
            .agencyId(userRole.getAgencyId())
            .assignedAt(userRole.getAssignedAt())
            .expiresAt(userRole.getExpiresAt())
            .isActive(userRole.getIsActive())
            .assignmentReason(userRole.getAssignmentReason())
            .assignedBy(userRole.getAssignedBy())
            .roleName(role.getName())
            .roleDescription(role.getDescription())
            .roleColor(role.getColor())
            .roleIcon(role.getIcon())
            .userFullName(user.getFullName())
            .userEmail(user.getEmail())
            .isExpired(userRole.isExpired())
            .daysUntilExpiration(userRole.getDaysUntilExpiration())
            .isExpiringSoon(userRole.isExpiringSoon(7))
            .build();
    }

    private List<PermissionGroupDto> groupPermissionsByResource(Set<String> userPermissions) {
        Map<String, List<Permission>> permissionsByResource = Arrays.stream(Permission.values())
            .collect(Collectors.groupingBy(Permission::getResource));

        return permissionsByResource.entrySet().stream()
            .map(entry -> {
                String resource = entry.getKey();
                List<Permission> permissions = entry.getValue();

                List<PermissionDto> permissionDtos = permissions.stream()
                    .map(permission -> PermissionDto.builder()
                        .code(permission.getCode())
                        .description(permission.getDescription())
                        .resource(permission.getResource())
                        .category(permission.getResource())
                        .isAssigned(userPermissions.contains(permission.getCode()))
                        .build())
                    .collect(Collectors.toList());

                long assignedCount = permissionDtos.stream()
                    .mapToLong(p -> Boolean.TRUE.equals(p.getIsAssigned()) ? 1 : 0)
                    .sum();

                return PermissionGroupDto.builder()
                    .resource(resource)
                    .resourceLabel(getResourceLabel(resource))
                    .description(getResourceDescription(resource))
                    .permissions(permissionDtos)
                    .totalPermissions(permissions.size())
                    .assignedPermissions((int) assignedCount)
                    .build();
            })
            .sorted(Comparator.comparing(PermissionGroupDto::getResourceLabel))
            .collect(Collectors.toList());
    }

    private String determineAccessLevel(Set<String> permissions) {
        if (permissions.contains(Permission.SYSTEM_ADMIN.getCode())) {
            return "ADMIN";
        } else if (permissions.contains(Permission.ORGANIZATION_UPDATE.getCode())) {
            return "MANAGER";
        } else if (permissions.size() > 10) {
            return "USER";
        } else {
            return "LIMITED";
        }
    }

    private String getResourceLabel(String resource) {
        return switch (resource.toUpperCase()) {
            case "VEHICLE" -> "Véhicules";
            case "DRIVER" -> "Chauffeurs";
            case "RENTAL" -> "Locations";
            case "USER" -> "Utilisateurs";
            case "AGENCY" -> "Agences";
            case "ORGANIZATION" -> "Organisation";
            case "ROLE" -> "Rôles";
            case "PAYMENT" -> "Paiements";
            case "REPORT" -> "Rapports";
            case "SETTINGS" -> "Paramètres";
            case "SYSTEM" -> "Système";
            default -> resource;
        };
    }

    private String getResourceDescription(String resource) {
        return switch (resource.toUpperCase()) {
            case "VEHICLE" -> "Gestion des véhicules de la flotte";
            case "DRIVER" -> "Gestion des chauffeurs";
            case "RENTAL" -> "Gestion des locations et réservations";
            case "USER" -> "Gestion des utilisateurs";
            case "AGENCY" -> "Gestion des agences";
            case "ORGANIZATION" -> "Gestion de l'organisation";
            case "ROLE" -> "Gestion des rôles et permissions";
            case "PAYMENT" -> "Gestion des paiements et transactions";
            case "REPORT" -> "Génération et consultation des rapports";
            case "SETTINGS" -> "Configuration des paramètres";
            case "SYSTEM" -> "Administration système";
            default -> "Permissions pour " + resource.toLowerCase();
        };
    }

    private List<RoleTemplateDto> getDefaultRoleTemplates() {
        return Arrays.asList(
            RoleTemplateDto.builder()
                .roleType(RoleType.ORGANIZATION_OWNER)
                .name("Propriétaire")
                .description("Propriétaire de l'organisation avec tous les droits")
                .defaultPermissions(Set.of(
                    Permission.ORGANIZATION_READ.getCode(),
                    Permission.ORGANIZATION_UPDATE.getCode(),
                    Permission.ORGANIZATION_MANAGE_SETTINGS.getCode(),
                    Permission.AGENCY_READ.getCode(),
                    Permission.AGENCY_WRITE.getCode(),
                    Permission.AGENCY_UPDATE.getCode(),
                    Permission.AGENCY_DELETE.getCode(),
                    Permission.ROLE_READ.getCode(),
                    Permission.ROLE_WRITE.getCode(),
                    Permission.ROLE_UPDATE.getCode(),
                    Permission.ROLE_DELETE.getCode(),
                    Permission.USER_READ.getCode(),
                    Permission.USER_WRITE.getCode(),
                    Permission.USER_UPDATE.getCode(),
                    Permission.USER_MANAGE_ROLES.getCode()
                ))
                .defaultPriority(100)
                .defaultColor("#FF6B35")
                .defaultIcon("crown")
                .isRecommended(true)
                .build(),

            RoleTemplateDto.builder()
                .roleType(RoleType.AGENCY_MANAGER)
                .name("Gestionnaire d'Agence")
                .description("Gestionnaire avec droits complets sur son agence")
                .defaultPermissions(Set.of(
                    Permission.VEHICLE_READ.getCode(),
                    Permission.VEHICLE_WRITE.getCode(),
                    Permission.VEHICLE_UPDATE.getCode(),
                    Permission.DRIVER_READ.getCode(),
                    Permission.DRIVER_WRITE.getCode(),
                    Permission.DRIVER_UPDATE.getCode(),
                    Permission.RENTAL_READ.getCode(),
                    Permission.RENTAL_WRITE.getCode(),
                    Permission.RENTAL_UPDATE.getCode(),
                    Permission.RENTAL_APPROVE.getCode(),
                    Permission.USER_READ.getCode(),
                    Permission.REPORT_READ.getCode(),
                    Permission.REPORT_GENERATE.getCode()
                ))
                .defaultPriority(80)
                .defaultColor("#4ECDC4")
                .defaultIcon("building")
                .isRecommended(true)
                .build(),

            RoleTemplateDto.builder()
                .roleType(RoleType.RENTAL_AGENT)
                .name("Agent de Location")
                .description("Agent responsable des locations")
                .defaultPermissions(Set.of(
                    Permission.VEHICLE_READ.getCode(),
                    Permission.DRIVER_READ.getCode(),
                    Permission.RENTAL_READ.getCode(),
                    Permission.RENTAL_WRITE.getCode(),
                    Permission.RENTAL_UPDATE.getCode(),
                    Permission.USER_READ.getCode()
                ))
                .defaultPriority(50)
                .defaultColor("#45B7D1")
                .defaultIcon("car")
                .isRecommended(true)
                .build(),

            RoleTemplateDto.builder()
                .roleType(RoleType.CLIENT)
                .name("Client")
                .description("Client final avec accès limité")
                .defaultPermissions(Set.of(
                    Permission.VEHICLE_READ.getCode(),
                    Permission.RENTAL_READ.getCode()
                ))
                .defaultPriority(10)
                .defaultColor("#96CEB4")
                .defaultIcon("user")
                .isRecommended(true)
                .build()
        );
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\annotations\RequireAgencyAccess.java ---

```java
package inc.yowyob.rental_api.security.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation pour vérifier qu'un utilisateur a accès à une agence spécifique
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireAgencyAccess {

    /**
     * Nom du paramètre contenant l'ID de l'agence
     */
    String agencyIdParam() default "agencyId";

    /**
     * Message d'erreur personnalisé
     */
    String message() default "Accès à l'agence non autorisé";

    /**
     * Indique si les gestionnaires d'organisation contournent cette vérification
     */
    boolean allowOrganizationManager() default true;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\annotations\RequireAllPermissions.java ---

```java
package inc.yowyob.rental_api.security.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation pour vérifier qu'un utilisateur possède toutes les permissions spécifiées
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireAllPermissions {

    /**
     * Liste des permissions (toutes requises)
     */
    String[] value();

    /**
     * Message d'erreur personnalisé
     */
    String message() default "Permissions insuffisantes";

    /**
     * Indique si la vérification doit inclure l'organisation courante
     */
    boolean checkOrganization() default true;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\annotations\RequireAnyPermission.java ---

```java
package inc.yowyob.rental_api.security.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation pour vérifier qu'un utilisateur possède au moins une des permissions spécifiées
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireAnyPermission {

    /**
     * Liste des permissions (une seule suffit)
     */
    String[] value();

    /**
     * Message d'erreur personnalisé
     */
    String message() default "Aucune permission suffisante";

    /**
     * Indique si la vérification doit inclure l'organisation courante
     */
    boolean checkOrganization() default true;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\annotations\RequireOrganizationAccess.java ---

```java
package inc.yowyob.rental_api.security.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation pour vérifier qu'un utilisateur a accès à une organisation spécifique
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireOrganizationAccess {

    /**
     * Nom du paramètre contenant l'ID de l'organisation
     */
    String organizationIdParam() default "organizationId";

    /**
     * Message d'erreur personnalisé
     */
    String message() default "Accès à l'organisation non autorisé";

    /**
     * Indique si les super admins contournent cette vérification
     */
    boolean allowSuperAdmin() default true;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\annotations\RequirePermission.java ---

```java
package inc.yowyob.rental_api.security.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation pour vérifier qu'un utilisateur possède une permission spécifique
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {

    /**
     * Code de la permission requise
     */
    String value();

    /**
     * Message d'erreur personnalisé
     */
    String message() default "Permission insuffisante";

    /**
     * Indique si la vérification doit inclure l'organisation courante
     */
    boolean checkOrganization() default true;

    /**
     * Indique si la vérification doit inclure l'agence courante
     */
    boolean checkAgency() default false;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\annotations\RequireRole.java ---

```java
package inc.yowyob.rental_api.security.annotations;

import inc.yowyob.rental_api.core.enums.RoleType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation pour vérifier qu'un utilisateur possède un rôle spécifique
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireRole {

    /**
     * Type de rôle requis
     */
    RoleType value();

    /**
     * Message d'erreur personnalisé
     */
    String message() default "Rôle insuffisant";

    /**
     * Indique si la vérification doit inclure l'organisation courante
     */
    boolean checkOrganization() default true;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\aspect\PermissionAspect.java ---

```java
package inc.yowyob.rental_api.security.aspect;

import inc.yowyob.rental_api.security.annotations.*;
import inc.yowyob.rental_api.security.service.PermissionEvaluationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.UUID;

/**
 * Aspect pour l'évaluation automatique des permissions via les annotations
 */
@Slf4j
@Aspect
@Component
@RequiredArgsConstructor
public class PermissionAspect {

    private final PermissionEvaluationService permissionEvaluationService;

    @Around("@annotation(requirePermission)")
    public Object checkPermission(ProceedingJoinPoint joinPoint, RequirePermission requirePermission) throws Throwable {
        log.debug("Checking permission: {} for method: {}",
            requirePermission.value(), joinPoint.getSignature().getName());

        boolean hasPermission;

        if (requirePermission.checkOrganization() || requirePermission.checkAgency()) {
            // Extraire les IDs d'organisation et d'agence des paramètres
            Object[] args = joinPoint.getArgs();
            Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
            Parameter[] parameters = method.getParameters();

            UUID organizationId = extractParameterValue(args, parameters, "organizationId", UUID.class);
            UUID agencyId = requirePermission.checkAgency() ?
                extractParameterValue(args, parameters, "agencyId", UUID.class) : null;

            hasPermission = permissionEvaluationService.hasPermissionInContext(
                requirePermission.value(), organizationId, agencyId);
        } else {
            hasPermission = permissionEvaluationService.hasPermission(requirePermission.value());
        }

        if (!hasPermission) {
            log.warn("Access denied - Missing permission: {} for method: {}",
                requirePermission.value(), joinPoint.getSignature().getName());
            throw new AccessDeniedException(requirePermission.message());
        }

        return joinPoint.proceed();
    }

    @Around("@annotation(requireAnyPermission)")
    public Object checkAnyPermission(ProceedingJoinPoint joinPoint, RequireAnyPermission requireAnyPermission) throws Throwable {
        log.debug("Checking any permission: {} for method: {}",
            String.join(", ", requireAnyPermission.value()), joinPoint.getSignature().getName());

        boolean hasAnyPermission = permissionEvaluationService.hasAnyPermission(requireAnyPermission.value());

        if (!hasAnyPermission) {
            log.warn("Access denied - Missing any required permission for method: {}",
                joinPoint.getSignature().getName());
            throw new AccessDeniedException(requireAnyPermission.message());
        }

        return joinPoint.proceed();
    }

    @Around("@annotation(requireAllPermissions)")
    public Object checkAllPermissions(ProceedingJoinPoint joinPoint, RequireAllPermissions requireAllPermissions) throws Throwable {
        log.debug("Checking all permissions: {} for method: {}",
            String.join(", ", requireAllPermissions.value()), joinPoint.getSignature().getName());

        boolean hasAllPermissions = permissionEvaluationService.hasAllPermissions(requireAllPermissions.value());

        if (!hasAllPermissions) {
            log.warn("Access denied - Missing required permissions for method: {}",
                joinPoint.getSignature().getName());
            throw new AccessDeniedException(requireAllPermissions.message());
        }

        return joinPoint.proceed();
    }

    @Around("@annotation(requireRole)")
    public Object checkRole(ProceedingJoinPoint joinPoint, RequireRole requireRole) throws Throwable {
        log.debug("Checking role: {} for method: {}",
            requireRole.value(), joinPoint.getSignature().getName());

        boolean hasRole = permissionEvaluationService.hasRole(requireRole.value());

        if (!hasRole) {
            log.warn("Access denied - Missing required role: {} for method: {}",
                requireRole.value(), joinPoint.getSignature().getName());
            throw new AccessDeniedException(requireRole.message());
        }

        return joinPoint.proceed();
    }

    @Around("@annotation(requireOrganizationAccess)")
    public Object checkOrganizationAccess(ProceedingJoinPoint joinPoint, RequireOrganizationAccess requireOrganizationAccess) throws Throwable {
        log.debug("Checking organization access for method: {}", joinPoint.getSignature().getName());

        // Extraire l'ID d'organisation des paramètres
        Object[] args = joinPoint.getArgs();
        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
        Parameter[] parameters = method.getParameters();

        UUID organizationId = extractParameterValue(args, parameters,
            requireOrganizationAccess.organizationIdParam(), UUID.class);

        if (organizationId == null) {
            log.warn("Organization ID parameter not found: {}", requireOrganizationAccess.organizationIdParam());
            throw new AccessDeniedException("Organization ID required");
        }

        // Vérifier l'accès (super admin contourne si autorisé)
        boolean hasAccess = (requireOrganizationAccess.allowSuperAdmin() && permissionEvaluationService.isSuperAdmin()) ||
            permissionEvaluationService.hasOrganizationAccess(organizationId);

        if (!hasAccess) {
            log.warn("Access denied - No access to organization: {} for method: {}",
                organizationId, joinPoint.getSignature().getName());
            throw new AccessDeniedException(requireOrganizationAccess.message());
        }

        return joinPoint.proceed();
    }

    @Around("@annotation(requireAgencyAccess)")
    public Object checkAgencyAccess(ProceedingJoinPoint joinPoint, RequireAgencyAccess requireAgencyAccess) throws Throwable {
        log.debug("Checking agency access for method: {}", joinPoint.getSignature().getName());

        // Extraire l'ID d'agence des paramètres
        Object[] args = joinPoint.getArgs();
        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
        Parameter[] parameters = method.getParameters();

        UUID agencyId = extractParameterValue(args, parameters,
            requireAgencyAccess.agencyIdParam(), UUID.class);

        if (agencyId == null) {
            log.warn("Agency ID parameter not found: {}", requireAgencyAccess.agencyIdParam());
            throw new AccessDeniedException("Agency ID required");
        }

        // Vérifier l'accès
        boolean hasAccess = (requireAgencyAccess.allowOrganizationManager() && permissionEvaluationService.isOrganizationOwner()) ||
            permissionEvaluationService.hasAgencyAccess(agencyId);

        if (!hasAccess) {
            log.warn("Access denied - No access to agency: {} for method: {}",
                agencyId, joinPoint.getSignature().getName());
            throw new AccessDeniedException(requireAgencyAccess.message());
        }

        return joinPoint.proceed();
    }

    /**
     * Extrait la valeur d'un paramètre par nom
     */
    @SuppressWarnings("unchecked")
    private <T> T extractParameterValue(Object[] args, Parameter[] parameters, String parameterName, Class<T> expectedType) {
        for (int i = 0; i < parameters.length && i < args.length; i++) {
            if (parameterName.equals(parameters[i].getName()) && args[i] != null) {
                if (expectedType.isAssignableFrom(args[i].getClass())) {
                    return (T) args[i];
                }
            }
        }
        return null;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\config\SecurityConfig.java ---

```java
package inc.yowyob.rental_api.security.config;

import inc.yowyob.rental_api.security.jwt.JwtAuthenticationFilter;
import inc.yowyob.rental_api.security.service.CustomUserDetailsService;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        // Origines autorisées
        configuration.setAllowedOriginPatterns(Arrays.asList(
            "http://localhost:3000",
            "http://localhost:8080",
            "http://localhost:4200",
            "https://*.rental-api.com"
        ));

        // Méthodes autorisées
        configuration.setAllowedMethods(Arrays.asList(
            "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"
        ));

        // Headers autorisés
        configuration.setAllowedHeaders(Arrays.asList(
            "Authorization",
            "Content-Type",
            "X-Requested-With",
            "Accept",
            "Origin",
            "Access-Control-Request-Method",
            "Access-Control-Request-Headers"
        ));

        // Headers exposés
        configuration.setExposedHeaders(Arrays.asList(
            "Access-Control-Allow-Origin",
            "Access-Control-Allow-Credentials"
        ));

        // Permettre les credentials
        configuration.setAllowCredentials(true);

        // Durée de cache pour les preflight requests
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // Configuration CORS
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))

            // Désactiver CSRF pour API REST
            .csrf(AbstractHttpConfigurer::disable)

            // Configuration des sessions (stateless pour JWT)
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )

            // Configuration des autorisations
            .authorizeHttpRequests(authz -> authz
                // Routes publiques - Authentification
                .requestMatchers("/api/v1/auth/**").permitAll()

                // Routes publiques - Onboarding
                .requestMatchers("/api/v1/onboarding/**").permitAll()

                // Routes publiques - Forfaits (consultation uniquement)
                .requestMatchers("/api/v1/subscription/plans").permitAll()
                .requestMatchers("/api/v1/subscription/plans/trial").permitAll()
                .requestMatchers("/api/v1/subscription/plans/with-*").permitAll()

                // Documentation API
                .requestMatchers(
                    "/v3/api-docs/**",
                    "/swagger-ui/**",
                    "/swagger-ui.html",
                    "/swagger-resources/**",
                    "/webjars/**"
                ).permitAll()

                // Health checks et actuator (si activé)
                .requestMatchers("/actuator/health").permitAll()

                // Toutes les autres routes nécessitent une authentification
                .anyRequest().authenticated()
            )

            // Configuration du provider d'authentification
            .authenticationProvider(authenticationProvider())

            // Ajouter le filtre JWT avant le filtre d'authentification standard
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\jwt\JwtAuthenticationFilter.java ---

```java
package inc.yowyob.rental_api.security.jwt;

import inc.yowyob.rental_api.security.service.CustomUserDetailsService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final CustomUserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        try {
            String bearerToken = request.getHeader("Authorization");
            String jwt = jwtTokenProvider.extractTokenFromHeader(bearerToken);

            if (jwt != null && jwtTokenProvider.validateToken(jwt)) {
                String email = jwtTokenProvider.getEmailFromToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(email);

                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());

                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            log.error("Cannot set user authentication: {}", e.getMessage());
        }

        filterChain.doFilter(request, response);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\jwt\JwtTokenProvider.java ---

```java
package inc.yowyob.rental_api.security.jwt;

import inc.yowyob.rental_api.config.AppProperties;
import inc.yowyob.rental_api.user.entities.User;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtTokenProvider {

    private final AppProperties appProperties;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(appProperties.getJwt().getSecret().getBytes());
    }

    /**
     * Génère un token JWT pour un utilisateur
     */
    public String generateToken(User user) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", user.getId().toString());
        claims.put("email", user.getEmail());
        claims.put("userType", user.getUserType().getCode());
        claims.put("status", user.getStatus().getCode());

        if (user.getOrganizationId() != null) {
            claims.put("organizationId", user.getOrganizationId().toString());
        }

        return createToken(claims, user.getEmail(), appProperties.getJwt().getExpiration());
    }

    /**
     * Génère un refresh token
     */
    public String generateRefreshToken(User user) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", user.getId().toString());
        claims.put("type", "refresh");

        return createToken(claims, user.getEmail(), appProperties.getJwt().getRefreshExpiration());
    }

    /**
     * Crée un token JWT
     */
    private String createToken(Map<String, Object> claims, String subject, long expirationTime) {
        Date now = new Date();
        Date expiry = new Date(now.getTime() + expirationTime);

        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(now)
            .setExpiration(expiry)
            .signWith(getSigningKey(), SignatureAlgorithm.HS256)
            .compact();
    }

    /**
     * Extrait l'email du token
     */
    public String getEmailFromToken(String token) {
        return getClaimsFromToken(token).getSubject();
    }

    /**
     * Extrait l'ID utilisateur du token
     */
    public UUID getUserIdFromToken(String token) {
        String userId = (String) getClaimsFromToken(token).get("userId");
        return UUID.fromString(userId);
    }

    /**
     * Extrait l'ID organisation du token
     */
    public UUID getOrganizationIdFromToken(String token) {
        String orgId = (String) getClaimsFromToken(token).get("organizationId");
        return orgId != null ? UUID.fromString(orgId) : null;
    }

    /**
     * Extrait le type d'utilisateur du token
     */
    public String getUserTypeFromToken(String token) {
        return (String) getClaimsFromToken(token).get("userType");
    }

    /**
     * Extrait la date d'expiration du token
     */
    public Date getExpirationFromToken(String token) {
        return getClaimsFromToken(token).getExpiration();
    }

    /**
     * Extrait tous les claims du token
     */
    private Claims getClaimsFromToken(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(getSigningKey())
            .build()
            .parseClaimsJws(token)
            .getBody();
    }

    /**
     * Vérifie si le token a expiré
     */
    public boolean isTokenExpired(String token) {
        Date expiration = getExpirationFromToken(token);
        return expiration.before(new Date());
    }

    /**
     * Valide le token JWT
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (MalformedJwtException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT claims string is empty: {}", e.getMessage());
        } catch (Exception e) {
            log.error("JWT validation error: {}", e.getMessage());
        }
        return false;
    }

    /**
     * Extrait le token du header Authorization
     */
    public String extractTokenFromHeader(String bearerToken) {
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\model\UserPrincipal.java ---

```java
package inc.yowyob.rental_api.security.model;

import inc.yowyob.rental_api.user.entities.User;
import lombok.AllArgsConstructor;
import lombok.Data;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.UUID;

@Data
@AllArgsConstructor
public class UserPrincipal implements UserDetails {

    private UUID id;
    private String email;
    private String password;
    private String firstName;
    private String lastName;
    private String userType;
    private String status;
    private UUID organizationId;
    private boolean accountNonLocked;
    private Collection<? extends GrantedAuthority> authorities;

    public static UserPrincipal create(User user) {
        Collection<GrantedAuthority> authorities = Collections.singletonList(
            new SimpleGrantedAuthority("ROLE_" + user.getUserType().getCode().toUpperCase())
        );

        return new UserPrincipal(
            user.getId(),
            user.getEmail(),
            user.getPassword(),
            user.getFirstName(),
            user.getLastName(),
            user.getUserType().getCode(),
            user.getStatus().getCode(),
            user.getOrganizationId(),
            !user.isLocked(),
            authorities
        );
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return "active".equals(status) || "pending_verification".equals(status);
    }

    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\service\CustomUserDetailsService.java ---

```java
package inc.yowyob.rental_api.security.service;

import inc.yowyob.rental_api.security.model.UserPrincipal;
import inc.yowyob.rental_api.user.entities.User;
import inc.yowyob.rental_api.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        log.debug("Loading user by email: {}", email);

        User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));

        return UserPrincipal.create(user);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\service\PermissionEvaluationService.java ---

```java
package inc.yowyob.rental_api.security.service;

import inc.yowyob.rental_api.core.enums.Permission;
import inc.yowyob.rental_api.core.enums.RoleType;
import inc.yowyob.rental_api.role.entities.UserRole;
import inc.yowyob.rental_api.role.repository.UserRoleRepository;
import inc.yowyob.rental_api.role.service.RoleService;
import inc.yowyob.rental_api.security.model.UserPrincipal;
import inc.yowyob.rental_api.security.util.SecurityUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.UUID;

/**
 * Service pour l'évaluation des permissions et des accès
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class PermissionEvaluationService {

    private final RoleService roleService;
    private final UserRoleRepository userRoleRepository;

    /**
     * Vérifie si l'utilisateur connecté possède une permission spécifique
     */
    public boolean hasPermission(String permissionCode) {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        if (currentUser == null) {
            return false;
        }

        return hasPermission(currentUser.getId(), permissionCode, currentUser.getOrganizationId());
    }

    /**
     * Vérifie si un utilisateur possède une permission spécifique dans une organisation
     */
    public boolean hasPermission(UUID userId, String permissionCode, UUID organizationId) {
        log.debug("Checking permission '{}' for user {} in organization {}", permissionCode, userId, organizationId);

        // Super admin a toutes les permissions
        if (isSuperAdmin(userId)) {
            return true;
        }

        // Vérifier si l'utilisateur a cette permission via ses rôles
        var userPermissions = roleService.getUserEffectivePermissions(userId, organizationId);
        return userPermissions.getEffectivePermissions().contains(permissionCode);
    }

    /**
     * Vérifie si l'utilisateur possède au moins une des permissions spécifiées
     */
    public boolean hasAnyPermission(String... permissionCodes) {
        return Arrays.stream(permissionCodes)
            .anyMatch(this::hasPermission);
    }

    /**
     * Vérifie si l'utilisateur possède toutes les permissions spécifiées
     */
    public boolean hasAllPermissions(String... permissionCodes) {
        return Arrays.stream(permissionCodes)
            .allMatch(this::hasPermission);
    }

    /**
     * Vérifie si l'utilisateur a un rôle spécifique
     */
    public boolean hasRole(RoleType roleType) {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        if (currentUser == null) {
            return false;
        }

        return hasRole(currentUser.getId(), roleType, currentUser.getOrganizationId());
    }

    /**
     * Vérifie si un utilisateur a un rôle spécifique dans une organisation
     */
    public boolean hasRole(UUID userId, RoleType roleType, UUID organizationId) {
        log.debug("Checking role '{}' for user {} in organization {}", roleType, userId, organizationId);

        List<UserRole> userRoles = userRoleRepository.findValidByUserId(userId, LocalDateTime.now());

        return userRoles.stream()
            .filter(ur -> organizationId.equals(ur.getOrganizationId()))
            .anyMatch(ur -> {
                try {
                    // Récupérer le rôle et vérifier son type
                    // Cette vérification serait faite via le RoleService
                    return true; // Simplifié pour l'exemple
                } catch (Exception e) {
                    log.error("Error checking role for user role {}: {}", ur.getId(), e.getMessage());
                    return false;
                }
            });
    }

    /**
     * Vérifie si l'utilisateur a accès à une organisation spécifique
     */
    public boolean hasOrganizationAccess(UUID organizationId) {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        if (currentUser == null) {
            return false;
        }

        // Super admin a accès à toutes les organisations
        if (isSuperAdmin(currentUser.getId())) {
            return true;
        }

        // Vérifier si l'utilisateur appartient à cette organisation
        return organizationId.equals(currentUser.getOrganizationId());
    }

    /**
     * Vérifie si l'utilisateur a accès à une agence spécifique
     */
    public boolean hasAgencyAccess(UUID agencyId) {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        if (currentUser == null) {
            return false;
        }

        // Super admin et propriétaires d'organisation ont accès à toutes les agences de leur org
        if (isSuperAdmin(currentUser.getId()) || isOrganizationOwner(currentUser.getId())) {
            return true;
        }

        // Vérifier si l'utilisateur a un rôle spécifique à cette agence
        List<UserRole> userRoles = userRoleRepository.findValidByUserId(currentUser.getId(), LocalDateTime.now());

        return userRoles.stream()
            .anyMatch(ur -> agencyId.equals(ur.getAgencyId()) || ur.getAgencyId() == null);
    }

    /**
     * Vérifie si l'utilisateur est super administrateur
     */
    public boolean isSuperAdmin() {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        return currentUser != null && isSuperAdmin(currentUser.getId());
    }

    /**
     * Vérifie si un utilisateur est super administrateur
     */
    public boolean isSuperAdmin(UUID userId) {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        if (currentUser != null && currentUser.getId().equals(userId)) {
            return "super_admin".equals(currentUser.getUserType());
        }

        // Pour les autres utilisateurs, vérifier dans la base
        // Cette vérification serait faite via le UserService
        return false;
    }

    /**
     * Vérifie si l'utilisateur est propriétaire de son organisation
     */
    public boolean isOrganizationOwner() {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        return currentUser != null && isOrganizationOwner(currentUser.getId());
    }

    /**
     * Vérifie si un utilisateur est propriétaire de son organisation
     */
    public boolean isOrganizationOwner(UUID userId) {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        if (currentUser != null && currentUser.getId().equals(userId)) {
            return "owner".equals(currentUser.getUserType());
        }

        return false;
    }

    /**
     * Vérifie si l'utilisateur peut accéder aux ressources d'un autre utilisateur
     */
    public boolean canAccessUserData(UUID targetUserId) {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        if (currentUser == null) {
            return false;
        }

        // Un utilisateur peut toujours accéder à ses propres données
        if (currentUser.getId().equals(targetUserId)) {
            return true;
        }

        // Super admin peut accéder aux données de tous
        if (isSuperAdmin()) {
            return true;
        }

        // Vérifier les permissions de gestion des utilisateurs
        return hasPermission(Permission.USER_READ.getCode());
    }

    /**
     * Évalue une expression de permission complexe
     */
    public boolean evaluatePermissionExpression(String expression) {
        log.debug("Evaluating permission expression: {}", expression);

        // Expression basique pour l'instant
        // Pourrait être étendue pour supporter des expressions complexes comme:
        // "VEHICLE_READ AND (AGENCY_MANAGE OR ORGANIZATION_OWNER)"

        if (expression.contains(" AND ")) {
            String[] permissions = expression.split(" AND ");
            return Arrays.stream(permissions)
                .map(String::trim)
                .allMatch(this::hasPermission);
        }

        if (expression.contains(" OR ")) {
            String[] permissions = expression.split(" OR ");
            return Arrays.stream(permissions)
                .map(String::trim)
                .anyMatch(this::hasPermission);
        }

        return hasPermission(expression.trim());
    }

    /**
     * Vérifie les permissions avec contexte d'organisation et d'agence
     */
    public boolean hasPermissionInContext(String permissionCode, UUID organizationId, UUID agencyId) {
        if (!hasOrganizationAccess(organizationId)) {
            return false;
        }

        if (agencyId != null && !hasAgencyAccess(agencyId)) {
            return false;
        }

        return hasPermission(permissionCode);
    }

    /**
     * Obtient le niveau d'accès d'un utilisateur (pour l'interface utilisateur)
     */
    public String getUserAccessLevel() {
        if (isSuperAdmin()) {
            return "SUPER_ADMIN";
        }

        if (isOrganizationOwner()) {
            return "ORGANIZATION_OWNER";
        }

        if (hasAnyPermission(
            Permission.AGENCY_WRITE.getCode(),
            Permission.AGENCY_UPDATE.getCode(),
            Permission.AGENCY_DELETE.getCode()
        )) {
            return "AGENCY_MANAGER";
        }

        if (hasAnyPermission(
            Permission.RENTAL_WRITE.getCode(),
            Permission.VEHICLE_WRITE.getCode(),
            Permission.DRIVER_WRITE.getCode()
        )) {
            return "OPERATIONAL_USER";
        }

        return "LIMITED_USER";
    }

    /**
     * Génère un résumé des permissions pour l'utilisateur connecté
     */
    public Set<String> getCurrentUserPermissions() {
        UserPrincipal currentUser = SecurityUtils.getCurrentUser();
        if (currentUser == null || currentUser.getOrganizationId() == null) {
            return Set.of();
        }

        var userPermissions = roleService.getUserEffectivePermissions(
            currentUser.getId(),
            currentUser.getOrganizationId()
        );

        return userPermissions.getEffectivePermissions();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\security\util\SecurityUtils.java ---

```java
package inc.yowyob.rental_api.security.util;

import inc.yowyob.rental_api.security.model.UserPrincipal;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.UUID;

public class SecurityUtils {

    /**
     * Récupère l'utilisateur connecté
     */
    public static UserPrincipal getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof UserPrincipal) {
            return (UserPrincipal) authentication.getPrincipal();
        }
        return null;
    }

    /**
     * Récupère l'ID de l'utilisateur connecté
     */
    public static UUID getCurrentUserId() {
        UserPrincipal user = getCurrentUser();
        return user != null ? user.getId() : null;
    }

    /**
     * Récupère l'email de l'utilisateur connecté
     */
    public static String getCurrentUserEmail() {
        UserPrincipal user = getCurrentUser();
        return user != null ? user.getEmail() : null;
    }

    /**
     * Récupère l'ID de l'organisation de l'utilisateur connecté
     */
    public static UUID getCurrentUserOrganizationId() {
        UserPrincipal user = getCurrentUser();
        return user != null ? user.getOrganizationId() : null;
    }

    /**
     * Vérifie si l'utilisateur connecté est authentifié
     */
    public static boolean isAuthenticated() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication != null &&
            authentication.isAuthenticated() &&
            authentication.getPrincipal() instanceof UserPrincipal;
    }

    /**
     * Vérifie si l'utilisateur connecté a un rôle spécifique
     */
    public static boolean hasRole(String role) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null) {
            return authentication.getAuthorities().stream()
                .anyMatch(authority -> authority.getAuthority().equals("ROLE_" + role.toUpperCase()));
        }
        return false;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\subscription\config\SubscriptionDataInitializer.java ---

```java
package inc.yowyob.rental_api.subscription.config;

import inc.yowyob.rental_api.subscription.entities.SubscriptionPlan;
import inc.yowyob.rental_api.subscription.repository.SubscriptionPlanRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Initialise les données de base pour les forfaits d'abonnement
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class SubscriptionDataInitializer implements CommandLineRunner {

    private final SubscriptionPlanRepository subscriptionPlanRepository;

    @Override
    public void run(String... args) throws Exception {
        log.info("Initializing subscription plans data...");

        try {
            // Vérifier si des plans existent déjà
            List<SubscriptionPlan> existingPlans = subscriptionPlanRepository.findAllActive();
            if (!existingPlans.isEmpty()) {
                log.info("Subscription plans already exist. Skipping initialization.");
                return;
            }

            createSubscriptionPlans();
            log.info("Subscription plans initialization completed successfully.");

        } catch (Exception e) {
            log.error("Error during subscription plans initialization: {}", e.getMessage(), e);
        }
    }

    private void createSubscriptionPlans() {
        log.info("Creating default subscription plans...");

        try {
            // Plan GRATUIT (Trial)
            SubscriptionPlan trialPlan = createTrialPlan();
            subscriptionPlanRepository.save(trialPlan);
            log.info("Created GRATUIT plan: {}", trialPlan.getId());

            // Plan BASIC
            SubscriptionPlan basicPlan = createBasicPlan();
            subscriptionPlanRepository.save(basicPlan);
            log.info("Created BASIC plan: {}", basicPlan.getId());

            // Plan PREMIUM
            SubscriptionPlan premiumPlan = createPremiumPlan();
            subscriptionPlanRepository.save(premiumPlan);
            log.info("Created PREMIUM plan: {}", premiumPlan.getId());

            // Plan ENTERPRISE
            SubscriptionPlan enterprisePlan = createEnterprisePlan();
            subscriptionPlanRepository.save(enterprisePlan);
            log.info("Created ENTERPRISE plan: {}", enterprisePlan.getId());

        } catch (Exception e) {
            log.error("Error creating subscription plans: {}", e.getMessage(), e);
            throw e;
        }
    }

    private SubscriptionPlan createTrialPlan() {
        SubscriptionPlan plan = new SubscriptionPlan();

        plan.setId(UUID.randomUUID());
        plan.setName("GRATUIT");
        plan.setDescription("Forfait d'essai gratuit de 30 jours pour découvrir notre plateforme");
        plan.setPrice(BigDecimal.ZERO);
        plan.setDurationDays(30);
        plan.setMaxAgencies(1);
        plan.setMaxVehicles(5);
        plan.setMaxDrivers(2);
        plan.setHasGeofencing(false);
        plan.setHasChat(false);
        plan.setHasAdvancedReports(false);
        plan.setHasApiAccess(false);
        plan.setHasPrioritySupport(false);
        plan.setIsActive(true);
        plan.setCreatedAt(LocalDateTime.now());
        plan.setUpdatedAt(LocalDateTime.now());

        return plan;
    }

    private SubscriptionPlan createBasicPlan() {
        SubscriptionPlan plan = new SubscriptionPlan();

        plan.setId(UUID.randomUUID());
        plan.setName("BASIC");
        plan.setDescription("Forfait de base idéal pour les petites entreprises de location");
        plan.setPrice(new BigDecimal("29.99"));
        plan.setDurationDays(30); // Mensuel
        plan.setMaxAgencies(3);
        plan.setMaxVehicles(20);
        plan.setMaxDrivers(10);
        plan.setHasGeofencing(false);
        plan.setHasChat(true);
        plan.setHasAdvancedReports(false);
        plan.setHasApiAccess(false);
        plan.setHasPrioritySupport(false);
        plan.setIsActive(true);
        plan.setCreatedAt(LocalDateTime.now());
        plan.setUpdatedAt(LocalDateTime.now());

        return plan;
    }

    private SubscriptionPlan createPremiumPlan() {
        SubscriptionPlan plan = new SubscriptionPlan();

        plan.setId(UUID.randomUUID());
        plan.setName("PREMIUM");
        plan.setDescription("Forfait premium avec fonctionnalités avancées pour les entreprises en croissance");
        plan.setPrice(new BigDecimal("79.99"));
        plan.setDurationDays(30); // Mensuel
        plan.setMaxAgencies(10);
        plan.setMaxVehicles(100);
        plan.setMaxDrivers(50);
        plan.setHasGeofencing(true);
        plan.setHasChat(true);
        plan.setHasAdvancedReports(true);
        plan.setHasApiAccess(true);
        plan.setHasPrioritySupport(false);
        plan.setIsActive(true);
        plan.setCreatedAt(LocalDateTime.now());
        plan.setUpdatedAt(LocalDateTime.now());

        return plan;
    }

    private SubscriptionPlan createEnterprisePlan() {
        SubscriptionPlan plan = new SubscriptionPlan();

        plan.setId(UUID.randomUUID());
        plan.setName("ENTERPRISE");
        plan.setDescription("Solution complète pour les grandes entreprises avec support dédié");
        plan.setPrice(new BigDecimal("199.99"));
        plan.setDurationDays(30); // Mensuel
        plan.setMaxAgencies(Integer.MAX_VALUE); // Illimité
        plan.setMaxVehicles(Integer.MAX_VALUE); // Illimité
        plan.setMaxDrivers(Integer.MAX_VALUE); // Illimité
        plan.setHasGeofencing(true);
        plan.setHasChat(true);
        plan.setHasAdvancedReports(true);
        plan.setHasApiAccess(true);
        plan.setHasPrioritySupport(true);
        plan.setIsActive(true);
        plan.setCreatedAt(LocalDateTime.now());
        plan.setUpdatedAt(LocalDateTime.now());

        return plan;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\subscription\controller\SubscriptionController.java ---

```java
package inc.yowyob.rental_api.subscription.controller;

import inc.yowyob.rental_api.subscription.entities.SubscriptionPlan;
import inc.yowyob.rental_api.subscription.service.SubscriptionService;
import inc.yowyob.rental_api.common.response.ApiResponse;
import inc.yowyob.rental_api.common.response.ApiResponseUtil;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/api/v1/subscription")
@RequiredArgsConstructor
@Tag(name = "Subscription Plans", description = "APIs de gestion des forfaits d'abonnement")
public class SubscriptionController {

    private final SubscriptionService subscriptionService;

    @Operation(
        summary = "Récupérer tous les forfaits disponibles",
        description = "Retourne la liste de tous les forfaits d'abonnement actifs disponibles pour les nouvelles organisations"
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200",
            description = "Liste des forfaits récupérée avec succès"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "500",
            description = "Erreur interne du serveur"
        )
    })
    @GetMapping("/plans")
    public ResponseEntity<ApiResponse<List<SubscriptionPlan>>> getAllPlans() {
        log.info("GET /subscription/plans - Fetching all subscription plans");

        try {
            List<SubscriptionPlan> plans = subscriptionService.getAllActivePlans();
            log.info("Successfully fetched {} subscription plans", plans.size());

            return ApiResponseUtil.success(
                plans,
                "Forfaits d'abonnement récupérés avec succès",
                plans.size()
            );
        } catch (Exception e) {
            log.error("Error fetching subscription plans", e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des forfaits d'abonnement",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer un forfait par ID",
        description = "Retourne les détails d'un forfait d'abonnement spécifique"
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200",
            description = "Forfait trouvé avec succès"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404",
            description = "Forfait non trouvé"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400",
            description = "ID de forfait invalide"
        )
    })
    @GetMapping("/plans/{planId}")
    public ResponseEntity<ApiResponse<SubscriptionPlan>> getPlanById(
        @Parameter(description = "ID du forfait d'abonnement")
        @PathVariable UUID planId
    ) {
        log.info("GET /subscription/plans/{} - Fetching subscription plan", planId);

        try {
            return subscriptionService.getPlanById(planId)
                .map(plan -> {
                    log.info("Successfully fetched subscription plan: {}", plan.getName());
                    return ApiResponseUtil.success(
                        plan,
                        "Forfait d'abonnement trouvé avec succès"
                    );
                })
                .orElseGet(() -> {
                    log.warn("Subscription plan not found: {}", planId);
                    return ApiResponseUtil.notFound(
                        "Forfait d'abonnement non trouvé"
                    );
                });
        } catch (IllegalArgumentException e) {
            log.warn("Invalid plan ID: {}", planId, e);
            return ApiResponseUtil.badRequest(
                "ID de forfait invalide"
            );
        } catch (Exception e) {
            log.error("Error fetching subscription plan: {}", planId, e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération du forfait d'abonnement",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer le forfait d'essai gratuit",
        description = "Retourne les détails du forfait d'essai gratuit de 30 jours"
    )
    @GetMapping("/plans/trial")
    public ResponseEntity<ApiResponse<SubscriptionPlan>> getTrialPlan() {
        log.info("GET /subscription/plans/trial - Fetching trial subscription plan");

        try {
            return subscriptionService.getTrialPlan()
                .map(plan -> {
                    log.info("Successfully fetched trial subscription plan");
                    return ApiResponseUtil.success(
                        plan,
                        "Forfait d'essai récupéré avec succès"
                    );
                })
                .orElseGet(() -> {
                    log.warn("Trial subscription plan not configured");
                    return ApiResponseUtil.notFound(
                        "Forfait d'essai non configuré"
                    );
                });
        } catch (Exception e) {
            log.error("Error fetching trial subscription plan", e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération du forfait d'essai",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer les forfaits avec géofencing",
        description = "Retourne la liste des forfaits incluant la fonctionnalité de géofencing"
    )
    @GetMapping("/plans/with-geofencing")
    public ResponseEntity<ApiResponse<List<SubscriptionPlan>>> getPlansWithGeofencing() {
        log.info("GET /subscription/plans/with-geofencing - Fetching plans with geofencing");

        try {
            // Pour l'instant, on filtre côté application
            List<SubscriptionPlan> plans = subscriptionService.getAllActivePlans()
                .stream()
                .filter(plan -> Boolean.TRUE.equals(plan.getHasGeofencing()))
                .toList();

            log.info("Successfully fetched {} plans with geofencing", plans.size());

            return ApiResponseUtil.success(
                plans,
                "Forfaits avec géofencing récupérés avec succès",
                plans.size()
            );
        } catch (Exception e) {
            log.error("Error fetching plans with geofencing", e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des forfaits avec géofencing",
                500
            );
        }
    }

    @Operation(
        summary = "Récupérer les forfaits avec chat",
        description = "Retourne la liste des forfaits incluant la fonctionnalité de chat"
    )
    @GetMapping("/plans/with-chat")
    public ResponseEntity<ApiResponse<List<SubscriptionPlan>>> getPlansWithChat() {
        log.info("GET /subscription/plans/with-chat - Fetching plans with chat");

        try {
            List<SubscriptionPlan> plans = subscriptionService.getAllActivePlans()
                .stream()
                .filter(plan -> Boolean.TRUE.equals(plan.getHasChat()))
                .toList();

            log.info("Successfully fetched {} plans with chat", plans.size());

            return ApiResponseUtil.success(
                plans,
                "Forfaits avec chat récupérés avec succès",
                plans.size()
            );
        } catch (Exception e) {
            log.error("Error fetching plans with chat", e);
            return ApiResponseUtil.error(
                "Erreur lors de la récupération des forfaits avec chat",
                500
            );
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\subscription\entities\OrganizationSubscription.java ---

```java
package inc.yowyob.rental_api.subscription.entities;

import inc.yowyob.rental_api.core.enums.SubscriptionStatus;
import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Table("organization_subscriptions")
public class OrganizationSubscription {

    @Id
    @PrimaryKey
    private UUID id;

    @NotNull(message = "Organization ID is required")
    private UUID organizationId;

    @NotNull(message = "Subscription plan ID is required")
    private UUID subscriptionPlanId;

    @NotNull(message = "Start date is required")
    private LocalDateTime startDate;

    @NotNull(message = "End date is required")
    private LocalDateTime endDate;

    @NotNull(message = "Status is required")
    private SubscriptionStatus status;

    @PositiveOrZero(message = "Amount paid must be positive or zero")
    private BigDecimal amountPaid;

    private String paymentTransactionId;
    private String paymentMethod;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // Auto-renewal configuration
    private Boolean autoRenewal = false;
    private UUID nextSubscriptionPlanId; // For plan changes

    // Trial specific fields
    private Boolean isTrial = false;
    private LocalDateTime trialStartDate;
    private LocalDateTime trialEndDate;

    // Constructors
    public OrganizationSubscription(UUID organizationId, UUID subscriptionPlanId,
                                    LocalDateTime startDate, LocalDateTime endDate) {
        this.id = UUID.randomUUID();
        this.organizationId = organizationId;
        this.subscriptionPlanId = subscriptionPlanId;
        this.startDate = startDate;
        this.endDate = endDate;
        this.status = SubscriptionStatus.ACTIVE;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // Business methods
    public boolean isActive() {
        LocalDateTime now = LocalDateTime.now();
        return status == SubscriptionStatus.ACTIVE &&
            now.isAfter(startDate) &&
            now.isBefore(endDate);
    }

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(endDate) ||
            status == SubscriptionStatus.EXPIRED;
    }

    public boolean isInTrial() {
        if (!Boolean.TRUE.equals(isTrial)) {
            return false;
        }
        LocalDateTime now = LocalDateTime.now();
        return trialStartDate != null && trialEndDate != null &&
            now.isAfter(trialStartDate) && now.isBefore(trialEndDate);
    }

    public long getDaysUntilExpiry() {
        if (endDate == null) {
            return 0;
        }
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDateTime.now(), endDate);
    }

    public boolean isExpiringIn(int days) {
        return getDaysUntilExpiry() <= days && getDaysUntilExpiry() > 0;
    }

    public void extendSubscription(int additionalDays) {
        if (endDate != null) {
            this.endDate = endDate.plusDays(additionalDays);
            this.updatedAt = LocalDateTime.now();
        }
    }

    public void cancel() {
        this.status = SubscriptionStatus.CANCELLED;
        this.autoRenewal = false;
        this.updatedAt = LocalDateTime.now();
    }

    public void suspend() {
        this.status = SubscriptionStatus.SUSPENDED;
        this.updatedAt = LocalDateTime.now();
    }

    public void reactivate() {
        if (status == SubscriptionStatus.SUSPENDED) {
            this.status = SubscriptionStatus.ACTIVE;
            this.updatedAt = LocalDateTime.now();
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\subscription\entities\SubscriptionPlan.java ---

```java
package inc.yowyob.rental_api.subscription.entities;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@AllArgsConstructor
@Getter
@Setter
@Table("subscription_plans")
public class SubscriptionPlan {

    @Id
    @PrimaryKey
    private UUID id;

    @NotBlank(message = "Plan name is required")
    private String name; // GRATUIT, BASIC, PREMIUM, ENTERPRISE

    private String description;

    @NotNull(message = "Price is required")
    @PositiveOrZero(message = "Price must be positive or zero")
    private BigDecimal price;

    @NotNull(message = "Duration is required")
    @PositiveOrZero(message = "Duration must be positive")
    private Integer durationDays;

    @NotNull(message = "Max agencies is required")
    @PositiveOrZero(message = "Max agencies must be positive")
    private Integer maxAgencies;

    @NotNull(message = "Max vehicles is required")
    @PositiveOrZero(message = "Max vehicles must be positive")
    private Integer maxVehicles;

    @NotNull(message = "Max drivers is required")
    @PositiveOrZero(message = "Max drivers must be positive")
    private Integer maxDrivers;

    private Boolean hasGeofencing = false;
    private Boolean hasChat = false;
    private Boolean hasAdvancedReports = false;
    private Boolean hasApiAccess = false;
    private Boolean hasPrioritySupport = false;

    private Boolean isActive = true;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // Constructors
    public SubscriptionPlan() {
        this.id = UUID.randomUUID();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.isActive = true;
    }

    public SubscriptionPlan(String name, String description, BigDecimal price,
                            Integer durationDays, Integer maxAgencies, Integer maxVehicles,
                            Integer maxDrivers) {
        this.id = UUID.randomUUID();
        this.name = name;
        this.description = description;
        this.price = price;
        this.durationDays = durationDays;
        this.maxAgencies = maxAgencies;
        this.maxVehicles = maxVehicles;
        this.maxDrivers = maxDrivers;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // Business methods
    public boolean isTrialPlan() {
        return "GRATUIT".equalsIgnoreCase(this.name);
    }

    public boolean hasFeature(String feature) {
        return switch (feature.toLowerCase()) {
            case "geofencing" -> Boolean.TRUE.equals(this.hasGeofencing);
            case "chat" -> Boolean.TRUE.equals(this.hasChat);
            case "advanced_reports" -> Boolean.TRUE.equals(this.hasAdvancedReports);
            case "api_access" -> Boolean.TRUE.equals(this.hasApiAccess);
            case "priority_support" -> Boolean.TRUE.equals(this.hasPrioritySupport);
            default -> false;
        };
    }

    public BigDecimal calculateMonthlyPrice() {
        if (durationDays == null || durationDays == 0) {
            return BigDecimal.ZERO;
        }
        return price.multiply(BigDecimal.valueOf(30))
            .divide(BigDecimal.valueOf(durationDays), 2, java.math.RoundingMode.HALF_UP);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\subscription\repository\OrganizationSubscriptionRepository.java ---

```java
package inc.yowyob.rental_api.subscription.repository;

import inc.yowyob.rental_api.core.enums.SubscriptionStatus;
import inc.yowyob.rental_api.subscription.entities.OrganizationSubscription;
import org.springframework.data.cassandra.repository.CassandraRepository;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface OrganizationSubscriptionRepository extends CassandraRepository<OrganizationSubscription, UUID> {

    /**
     * Trouve la souscription active d'une organisation
     */
    @Query("SELECT * FROM organization_subscriptions WHERE organization_id = ?0 AND status = 'ACTIVE' ALLOW FILTERING")
    Optional<OrganizationSubscription> findActiveByOrganizationId(UUID organizationId);

    /**
     * Trouve toutes les souscriptions d'une organisation
     */
    @Query("SELECT * FROM organization_subscriptions WHERE organization_id = ?0 ALLOW FILTERING")
    List<OrganizationSubscription> findAllByOrganizationId(UUID organizationId);

    /**
     * Trouve les souscriptions par statut
     */
    @Query("SELECT * FROM organization_subscriptions WHERE status = ?0 ALLOW FILTERING")
    List<OrganizationSubscription> findAllByStatus(SubscriptionStatus status);

    /**
     * Trouve les souscriptions qui expirent bientôt
     */
    @Query("SELECT * FROM organization_subscriptions WHERE end_date <= ?0 AND status = 'ACTIVE' ALLOW FILTERING")
    List<OrganizationSubscription> findExpiringSoon(LocalDateTime expirationDate);

    /**
     * Trouve les souscriptions expirées
     */
    @Query("SELECT * FROM organization_subscriptions WHERE end_date < ?0 AND status = 'ACTIVE' ALLOW FILTERING")
    List<OrganizationSubscription> findExpired(LocalDateTime now);

    /**
     * Trouve les souscriptions d'essai
     */
    @Query("SELECT * FROM organization_subscriptions WHERE is_trial = true ALLOW FILTERING")
    List<OrganizationSubscription> findAllTrials();

    /**
     * Trouve les souscriptions d'essai actives
     */
    @Query("SELECT * FROM organization_subscriptions WHERE is_trial = true AND status = 'ACTIVE' ALLOW FILTERING")
    List<OrganizationSubscription> findActiveTrials();

    /**
     * Trouve les souscriptions par plan
     */
    @Query("SELECT * FROM organization_subscriptions WHERE subscription_plan_id = ?0 ALLOW FILTERING")
    List<OrganizationSubscription> findAllBySubscriptionPlanId(UUID subscriptionPlanId);

    /**
     * Compte les souscriptions actives par plan
     */
    @Query("SELECT COUNT(*) FROM organization_subscriptions WHERE subscription_plan_id = ?0 AND status = 'ACTIVE' ALLOW FILTERING")
    Long countActiveBySubscriptionPlanId(UUID subscriptionPlanId);

    /**
     * Trouve les souscriptions avec renouvellement automatique
     */
    @Query("SELECT * FROM organization_subscriptions WHERE auto_renewal = true AND status = 'ACTIVE' ALLOW FILTERING")
    List<OrganizationSubscription> findAllWithAutoRenewal();
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\subscription\repository\SubscriptionPlanRepository.java ---

```java
package inc.yowyob.rental_api.subscription.repository;

import inc.yowyob.rental_api.subscription.entities.SubscriptionPlan;
import org.springframework.data.cassandra.repository.CassandraRepository;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface SubscriptionPlanRepository extends CassandraRepository<SubscriptionPlan, UUID> {

    /**
     * Trouve tous les plans actifs
     */
    @Query("SELECT * FROM subscription_plans WHERE isactive = true ALLOW FILTERING")
    List<SubscriptionPlan> findAllActive();

    /**
     * Trouve un plan par nom
     */
    @Query("SELECT * FROM subscription_plans WHERE name = ?0 ALLOW FILTERING")
    Optional<SubscriptionPlan> findByName(String name);

    /**
     * Trouve tous les plans avec une fonctionnalité spécifique
     */
    @Query("SELECT * FROM subscription_plans WHERE has_geofencing = true AND isactive = true ALLOW FILTERING")
    List<SubscriptionPlan> findAllWithGeofencing();

    @Query("SELECT * FROM subscription_plans WHERE has_chat = true AND isactive = true ALLOW FILTERING")
    List<SubscriptionPlan> findAllWithChat();

    @Query("SELECT * FROM subscription_plans WHERE has_advanced_reports = true AND isactive = true ALLOW FILTERING")
    List<SubscriptionPlan> findAllWithAdvancedReports();

    /**
     * Trouve les plans par gamme de prix
     */
    @Query("SELECT * FROM subscription_plans WHERE price >= ?0 AND price <= ?1 AND isactive = true ALLOW FILTERING")
    List<SubscriptionPlan> findByPriceRange(java.math.BigDecimal minPrice, java.math.BigDecimal maxPrice);

    /**
     * Trouve le plan gratuit
     */
    default Optional<SubscriptionPlan> findTrialPlan() {
        return findByName("GRATUIT");
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\subscription\service\SubscriptionService.java ---

```java
package inc.yowyob.rental_api.subscription.service;

import inc.yowyob.rental_api.core.enums.SubscriptionStatus;
import inc.yowyob.rental_api.subscription.entities.OrganizationSubscription;
import inc.yowyob.rental_api.subscription.entities.SubscriptionPlan;
import inc.yowyob.rental_api.subscription.repository.OrganizationSubscriptionRepository;
import inc.yowyob.rental_api.subscription.repository.SubscriptionPlanRepository;
import inc.yowyob.rental_api.config.AppProperties;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class SubscriptionService {

    private final SubscriptionPlanRepository subscriptionPlanRepository;
    private final OrganizationSubscriptionRepository organizationSubscriptionRepository;
    private final AppProperties appProperties;

    /**
     * Récupère tous les plans d'abonnement actifs
     */
    public List<SubscriptionPlan> getAllActivePlans() {
        log.debug("Fetching all active subscription plans");
        return subscriptionPlanRepository.findAllActive();
    }

    /**
     * Récupère un plan d'abonnement par ID
     */
    public Optional<SubscriptionPlan> getPlanById(UUID planId) {
        log.debug("Fetching subscription plan with ID: {}", planId);
        return subscriptionPlanRepository.findById(planId);
    }

    /**
     * Récupère le plan d'essai gratuit
     */
    public Optional<SubscriptionPlan> getTrialPlan() {
        log.debug("Fetching trial subscription plan");
        return subscriptionPlanRepository.findTrialPlan();
    }

    /**
     * Crée une nouvelle souscription pour une organisation
     */
    public OrganizationSubscription createSubscription(UUID organizationId, UUID planId,
                                                       String paymentMethod, String transactionId,
                                                       BigDecimal amountPaid) {
        log.info("Creating subscription for organization: {} with plan: {}", organizationId, planId);

        // Vérifier qu'il n'y a pas déjà une souscription active
        Optional<OrganizationSubscription> existingSubscription =
            organizationSubscriptionRepository.findActiveByOrganizationId(organizationId);

        if (existingSubscription.isPresent()) {
            throw new IllegalStateException("Organization already has an active subscription");
        }

        // Récupérer le plan
        SubscriptionPlan plan = subscriptionPlanRepository.findById(planId)
            .orElseThrow(() -> new IllegalArgumentException("Subscription plan not found"));

        // Calculer les dates
        LocalDateTime startDate = LocalDateTime.now();
        LocalDateTime endDate = startDate.plusDays(plan.getDurationDays());

        // Créer la souscription
        OrganizationSubscription subscription = new OrganizationSubscription(
            organizationId, planId, startDate, endDate
        );

        subscription.setPaymentMethod(paymentMethod);
        subscription.setPaymentTransactionId(transactionId);
        subscription.setAmountPaid(amountPaid);
        subscription.setStatus(SubscriptionStatus.ACTIVE);

        // Marquer comme essai si c'est le plan gratuit
        if (plan.isTrialPlan()) {
            subscription.setIsTrial(true);
            subscription.setTrialStartDate(startDate);
            subscription.setTrialEndDate(endDate);
        }

        OrganizationSubscription saved = organizationSubscriptionRepository.save(subscription);
        log.info("Subscription created successfully with ID: {}", saved.getId());

        return saved;
    }

    /**
     * Crée une souscription d'essai
     */
    public OrganizationSubscription createTrialSubscription(UUID organizationId) {
        log.info("Creating trial subscription for organization: {}", organizationId);

        SubscriptionPlan trialPlan = getTrialPlan()
            .orElseThrow(() -> new IllegalStateException("Trial plan not configured"));

        return createSubscription(organizationId, trialPlan.getId(), "TRIAL", null, BigDecimal.ZERO);
    }

    /**
     * Récupère la souscription active d'une organisation
     */
    public Optional<OrganizationSubscription> getActiveSubscription(UUID organizationId) {
        log.debug("Fetching active subscription for organization: {}", organizationId);
        return organizationSubscriptionRepository.findActiveByOrganizationId(organizationId);
    }

    /**
     * Vérifie si une organisation a une souscription active
     */
    public boolean hasActiveSubscription(UUID organizationId) {
        return getActiveSubscription(organizationId)
            .map(OrganizationSubscription::isActive)
            .orElse(false);
    }

    /**
     * Vérifie si une fonctionnalité est disponible pour une organisation
     */
    public boolean hasFeature(UUID organizationId, String feature) {
        log.debug("Checking feature '{}' for organization: {}", feature, organizationId);

        Optional<OrganizationSubscription> subscription = getActiveSubscription(organizationId);
        if (subscription.isEmpty() || !subscription.get().isActive()) {
            return false;
        }

        UUID planId = subscription.get().getSubscriptionPlanId();
        Optional<SubscriptionPlan> plan = getPlanById(planId);

        return plan.map(p -> p.hasFeature(feature)).orElse(false);
    }

    /**
     * Vérifie les limites de ressources pour une organisation
     */
    public boolean canCreateAgency(UUID organizationId, int currentCount) {
        return checkResourceLimit(organizationId, "agencies", currentCount);
    }

    public boolean canCreateVehicle(UUID organizationId, int currentCount) {
        return checkResourceLimit(organizationId, "vehicles", currentCount);
    }

    public boolean canCreateDriver(UUID organizationId, int currentCount) {
        return checkResourceLimit(organizationId, "drivers", currentCount);
    }

    private boolean checkResourceLimit(UUID organizationId, String resourceType, int currentCount) {
        Optional<OrganizationSubscription> subscription = getActiveSubscription(organizationId);
        if (subscription.isEmpty() || !subscription.get().isActive()) {
            return false;
        }

        UUID planId = subscription.get().getSubscriptionPlanId();
        Optional<SubscriptionPlan> plan = getPlanById(planId);

        if (plan.isEmpty()) {
            return false;
        }

        SubscriptionPlan subscriptionPlan = plan.get();
        return switch (resourceType) {
            case "agencies" -> currentCount < subscriptionPlan.getMaxAgencies();
            case "vehicles" -> currentCount < subscriptionPlan.getMaxVehicles();
            case "drivers" -> currentCount < subscriptionPlan.getMaxDrivers();
            default -> false;
        };
    }

    /**
     * Renouvelle une souscription
     */
    public OrganizationSubscription renewSubscription(UUID subscriptionId, String paymentMethod,
                                                      String transactionId, BigDecimal amountPaid) {
        log.info("Renewing subscription: {}", subscriptionId);

        OrganizationSubscription subscription = organizationSubscriptionRepository.findById(subscriptionId)
            .orElseThrow(() -> new IllegalArgumentException("Subscription not found"));

        SubscriptionPlan plan = getPlanById(subscription.getSubscriptionPlanId())
            .orElseThrow(() -> new IllegalArgumentException("Subscription plan not found"));

        // Étendre la période
        subscription.extendSubscription(plan.getDurationDays());
        subscription.setStatus(SubscriptionStatus.ACTIVE);
        subscription.setPaymentMethod(paymentMethod);
        subscription.setPaymentTransactionId(transactionId);
        subscription.setAmountPaid(amountPaid);

        OrganizationSubscription renewed = organizationSubscriptionRepository.save(subscription);
        log.info("Subscription renewed successfully until: {}", renewed.getEndDate());

        return renewed;
    }

    /**
     * Annule une souscription
     */
    public void cancelSubscription(UUID subscriptionId) {
        log.info("Cancelling subscription: {}", subscriptionId);

        OrganizationSubscription subscription = organizationSubscriptionRepository.findById(subscriptionId)
            .orElseThrow(() -> new IllegalArgumentException("Subscription not found"));

        subscription.cancel();
        organizationSubscriptionRepository.save(subscription);

        log.info("Subscription cancelled successfully");
    }

    /**
     * Trouve les souscriptions qui expirent bientôt
     */
    public List<OrganizationSubscription> findExpiringSoon(int days) {
        LocalDateTime expirationDate = LocalDateTime.now().plusDays(days);
        return organizationSubscriptionRepository.findExpiringSoon(expirationDate);
    }

    /**
     * Met à jour les souscriptions expirées
     */
    public void updateExpiredSubscriptions() {
        log.info("Updating expired subscriptions");

        List<OrganizationSubscription> expiredSubscriptions =
            organizationSubscriptionRepository.findExpired(LocalDateTime.now());

        for (OrganizationSubscription subscription : expiredSubscriptions) {
            subscription.setStatus(SubscriptionStatus.EXPIRED);
            organizationSubscriptionRepository.save(subscription);
        }

        log.info("Updated {} expired subscriptions", expiredSubscriptions.size());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\config\UserDataInitializer.java ---

```java
package inc.yowyob.rental_api.user.config;

import inc.yowyob.rental_api.core.enums.UserStatus;
import inc.yowyob.rental_api.core.enums.UserType;
import inc.yowyob.rental_api.user.entities.User;
import inc.yowyob.rental_api.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * Initialise les données de base pour les utilisateurs
 */
@Slf4j
@Component
@Order(2) // Après SubscriptionDataInitializer
@RequiredArgsConstructor
public class UserDataInitializer implements CommandLineRunner {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    @Override
    public void run(String... args) throws Exception {
        log.info("Initializing user data...");

        try {
            createSuperAdminUser();
            log.info("User data initialization completed successfully.");

        } catch (Exception e) {
            log.error("Error during user data initialization: {}", e.getMessage(), e);
        }
    }

    private void createSuperAdminUser() {
        String adminEmail = "admin@rental-api.com";

        if (userRepository.findByEmail(adminEmail).isEmpty()) {
            log.info("Creating super admin user...");

            User admin = new User(
                adminEmail,
                passwordEncoder.encode("Admin123!"),
                "Super",
                "Admin",
                UserType.SUPER_ADMIN
            );

            admin.setStatus(UserStatus.ACTIVE);
            admin.setEmailVerified(true);
            admin.setPhoneVerified(true);
            admin.setCreatedAt(LocalDateTime.now());
            admin.setUpdatedAt(LocalDateTime.now());

            userRepository.save(admin);
            log.info("Super admin user created successfully with email: {}", adminEmail);
        } else {
            log.info("Super admin user already exists. Skipping creation.");
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\controller\AuthController.java ---

```java
package inc.yowyob.rental_api.user.controller;

import inc.yowyob.rental_api.common.response.ApiResponse;
import inc.yowyob.rental_api.common.response.ApiResponseUtil;
import inc.yowyob.rental_api.security.util.SecurityUtils;
import inc.yowyob.rental_api.user.dto.*;
import inc.yowyob.rental_api.user.service.AuthService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
@Tag(name = "Authentication", description = "APIs d'authentification et de gestion des utilisateurs")
public class AuthController {

    private final AuthService authService;

    @Operation(
        summary = "Connexion utilisateur",
        description = "Authentifie un utilisateur avec email et mot de passe"
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200",
            description = "Connexion réussie"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400",
            description = "Données d'entrée invalides"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "401",
            description = "Email ou mot de passe incorrect"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "423",
            description = "Compte temporairement verrouillé"
        )
    })
    @PostMapping("/login")
    public ResponseEntity<ApiResponse<AuthResponseDto>> login(
        @Parameter(description = "Informations de connexion")
        @Valid @RequestBody LoginRequestDto loginRequest,
        HttpServletRequest request
    ) {
        log.info("POST /auth/login - Login attempt for email: {}", loginRequest.getEmail());

        try {
            String ipAddress = getClientIpAddress(request);
            AuthResponseDto authResponse = authService.login(loginRequest, ipAddress);

            log.info("Successful login for user: {}", loginRequest.getEmail());

            return ApiResponseUtil.success(
                authResponse,
                "Connexion réussie"
            );
        } catch (BadCredentialsException e) {
            log.warn("Failed login attempt for email: {}", loginRequest.getEmail());
            return ApiResponseUtil.unauthorized("Email ou mot de passe incorrect");
        } catch (DisabledException e) {
            log.warn("Login attempt for disabled account: {}", loginRequest.getEmail());
            return ApiResponseUtil.error(e.getMessage(), 423);
        } catch (Exception e) {
            log.error("Error during login for email: {}", loginRequest.getEmail(), e);
            return ApiResponseUtil.error("Erreur lors de la connexion", 500);
        }
    }

    @Operation(
        summary = "Inscription utilisateur",
        description = "Crée un nouveau compte utilisateur"
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "201",
            description = "Compte créé avec succès"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400",
            description = "Données d'entrée invalides"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "409",
            description = "Email déjà utilisé"
        )
    })
    @PostMapping("/register")
    public ResponseEntity<ApiResponse<AuthResponseDto>> register(
        @Parameter(description = "Informations d'inscription")
        @Valid @RequestBody RegisterRequestDto registerRequest
    ) {
        log.info("POST /auth/register - Registration attempt for email: {}", registerRequest.getEmail());

        try {
            AuthResponseDto authResponse = authService.register(registerRequest);

            log.info("Successful registration for user: {}", registerRequest.getEmail());

            return ApiResponseUtil.created(
                authResponse,
                "Compte créé avec succès"
            );
        } catch (IllegalArgumentException e) {
            log.warn("Registration failed for email: {} - {}", registerRequest.getEmail(), e.getMessage());
            return ApiResponseUtil.conflict(e.getMessage());
        } catch (Exception e) {
            log.error("Error during registration for email: {}", registerRequest.getEmail(), e);
            return ApiResponseUtil.error("Erreur lors de la création du compte", 500);
        }
    }

    @Operation(
        summary = "Rafraîchir le token",
        description = "Génère un nouveau token d'accès à partir du refresh token"
    )
    @PostMapping("/refresh")
    public ResponseEntity<ApiResponse<AuthResponseDto>> refreshToken(
        @Parameter(description = "Refresh token")
        @Valid @RequestBody RefreshTokenRequestDto refreshRequest
    ) {
        log.debug("POST /auth/refresh - Token refresh request");

        try {
            AuthResponseDto authResponse = authService.refreshToken(refreshRequest.getRefreshToken());

            return ApiResponseUtil.success(
                authResponse,
                "Token rafraîchi avec succès"
            );
        } catch (BadCredentialsException e) {
            log.warn("Invalid refresh token provided");
            return ApiResponseUtil.unauthorized("Token de rafraîchissement invalide");
        } catch (DisabledException e) {
            log.warn("Refresh token request for disabled account");
            return ApiResponseUtil.forbidden("Compte non actif");
        } catch (Exception e) {
            log.error("Error during token refresh", e);
            return ApiResponseUtil.error("Erreur lors du rafraîchissement du token", 500);
        }
    }

    @Operation(
        summary = "Changer le mot de passe",
        description = "Change le mot de passe de l'utilisateur connecté"
    )
    @PostMapping("/change-password")
    public ResponseEntity<ApiResponse<Void>> changePassword(
        @Parameter(description = "Informations de changement de mot de passe")
        @Valid @RequestBody ChangePasswordRequestDto changePasswordRequest,
        HttpServletRequest request
    ) {
        log.info("POST /auth/change-password - Password change request");

        try {
            // TODO: Récupérer l'ID utilisateur depuis le token JWT
             UUID userId = SecurityUtils.getCurrentUserId();
             authService.changePassword(userId, changePasswordRequest.getCurrentPassword(),
                                      changePasswordRequest.getNewPassword());

            return ApiResponseUtil.success(
                null,
                "Mot de passe changé avec succès"
            );
        } catch (BadCredentialsException e) {
            log.warn("Invalid current password provided");
            return ApiResponseUtil.badRequest("Mot de passe actuel incorrect");
        } catch (Exception e) {
            log.error("Error during password change", e);
            return ApiResponseUtil.error("Erreur lors du changement de mot de passe", 500);
        }
    }

    @Operation(
        summary = "Déconnexion",
        description = "Déconnecte l'utilisateur (invalide le token côté client)"
    )
    @PostMapping("/logout")
    public ResponseEntity<ApiResponse<Void>> logout() {
        log.info("POST /auth/logout - Logout request");

        // Note: Avec JWT stateless, la déconnexion se fait côté client
        // En supprimant le token du storage local

        return ApiResponseUtil.success(
            null,
            "Déconnexion réussie"
        );
    }

    /**
     * Extrait l'adresse IP du client
     */
    private String getClientIpAddress(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }

        String xRealIp = request.getHeader("X-Real-IP");
        if (xRealIp != null && !xRealIp.isEmpty()) {
            return xRealIp;
        }

        return request.getRemoteAddr();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\dto\AuthResponseDto.java ---

```java
package inc.yowyob.rental_api.user.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AuthResponseDto {

    private String accessToken;
    private String refreshToken;
    private String tokenType = "Bearer";
    private long expiresIn;

    private UUID userId;
    private String email;
    private String firstName;
    private String lastName;
    private String userType;
    private String status;
    private UUID organizationId;
    private Boolean emailVerified;
    private Boolean phoneVerified;

    private LocalDateTime lastLoginAt;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\dto\ChangePasswordRequestDto.java ---

```java
package inc.yowyob.rental_api.user.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChangePasswordRequestDto {

    @NotBlank(message = "Current password is required")
    private String currentPassword;

    @NotBlank(message = "New password is required")
    @Size(min = 8, message = "New password must be at least 8 characters")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$",
        message = "New password must contain at least one lowercase letter, one uppercase letter, and one number")
    private String newPassword;

    @NotBlank(message = "Password confirmation is required")
    private String confirmPassword;

    @AssertTrue(message = "Password confirmation must match new password")
    private boolean isPasswordConfirmed() {
        return newPassword != null && newPassword.equals(confirmPassword);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\dto\LoginRequestDto.java ---

```java
package inc.yowyob.rental_api.user.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequestDto {

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters")
    private String password;

    private Boolean rememberMe = false;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\dto\RefreshTokenRequestDto.java ---

```java
package inc.yowyob.rental_api.user.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotBlank;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class RefreshTokenRequestDto {

    @NotBlank(message = "Refresh token is required")
    private String refreshToken;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\dto\RegisterRequestDto.java ---

```java
package inc.yowyob.rental_api.user.dto;

import inc.yowyob.rental_api.core.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class RegisterRequestDto {

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$",
        message = "Password must contain at least one lowercase letter, one uppercase letter, and one number")
    private String password;

    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50)
    private String firstName;

    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50)
    private String lastName;

    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    private String phone;

    @NotNull(message = "User type is required")
    private UserType userType = UserType.CLIENT;

    @AssertTrue(message = "You must accept the terms and conditions")
    private Boolean acceptTerms = false;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\entities\User.java ---

```java
package inc.yowyob.rental_api.user.entities;

import inc.yowyob.rental_api.core.enums.UserStatus;
import inc.yowyob.rental_api.core.enums.UserType;
import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Table("users")
public class User {

    @Id
    @PrimaryKey
    private UUID id;

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;

    @NotBlank(message = "Password is required")
    private String password;

    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50)
    private String firstName;

    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50)
    private String lastName;

    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    private String phone;

    @NotNull(message = "User type is required")
    private UserType userType;

    @NotNull(message = "User status is required")
    private UserStatus status;

    private UUID organizationId;
    private String profileImageUrl;
    private String address;
    private String city;
    private String country;

    // Email verification
    private Boolean emailVerified = false;
    private String emailVerificationToken;
    private LocalDateTime emailVerificationExpiry;

    // Phone verification
    private Boolean phoneVerified = false;
    private String phoneVerificationCode;
    private LocalDateTime phoneVerificationExpiry;

    // Password reset
    private String passwordResetToken;
    private LocalDateTime passwordResetExpiry;

    // Security
    private LocalDateTime lastLoginAt;
    private String lastLoginIp;
    private Integer failedLoginAttempts = 0;
    private LocalDateTime lockedUntil;

    // Audit
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private UUID createdBy;
    private UUID updatedBy;

    // Constructors
    public User(String email, String password, String firstName, String lastName, UserType userType) {
        this.id = UUID.randomUUID();
        this.email = email;
        this.password = password;
        this.firstName = firstName;
        this.lastName = lastName;
        this.userType = userType;
        this.status = UserStatus.PENDING_VERIFICATION;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // Business methods
    public String getFullName() {
        return firstName + " " + lastName;
    }

    public boolean canLogin() {
        return status.canLogin() && !isLocked();
    }

    public boolean isLocked() {
        return lockedUntil != null && LocalDateTime.now().isBefore(lockedUntil);
    }

    public void lockAccount(int hours) {
        this.lockedUntil = LocalDateTime.now().plusHours(hours);
        this.updatedAt = LocalDateTime.now();
    }

    public void unlockAccount() {
        this.lockedUntil = null;
        this.failedLoginAttempts = 0;
        this.updatedAt = LocalDateTime.now();
    }

    public void incrementFailedLoginAttempts() {
        this.failedLoginAttempts++;
        this.updatedAt = LocalDateTime.now();

        // Lock account after 5 failed attempts for 1 hour
        if (this.failedLoginAttempts >= 5) {
            lockAccount(1);
        }
    }

    public void resetFailedLoginAttempts() {
        this.failedLoginAttempts = 0;
        this.updatedAt = LocalDateTime.now();
    }

    public void updateLastLogin(String ipAddress) {
        this.lastLoginAt = LocalDateTime.now();
        this.lastLoginIp = ipAddress;
        this.updatedAt = LocalDateTime.now();
        resetFailedLoginAttempts();
    }

    public void verifyEmail() {
        this.emailVerified = true;
        this.emailVerificationToken = null;
        this.emailVerificationExpiry = null;
        this.updatedAt = LocalDateTime.now();
    }

    public void verifyPhone() {
        this.phoneVerified = true;
        this.phoneVerificationCode = null;
        this.phoneVerificationExpiry = null;
        this.updatedAt = LocalDateTime.now();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\repository\UserRepository.java ---

```java
package inc.yowyob.rental_api.user.repository;

import inc.yowyob.rental_api.core.enums.UserStatus;
import inc.yowyob.rental_api.core.enums.UserType;
import inc.yowyob.rental_api.user.entities.User;
import org.springframework.data.cassandra.repository.CassandraRepository;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface UserRepository extends CassandraRepository<User, UUID> {

    /**
     * Trouve un utilisateur par email
     */
    @Query("SELECT * FROM users WHERE email = ?0 ALLOW FILTERING")
    Optional<User> findByEmail(String email);

    /**
     * Vérifie si un email existe déjà dans le système
     */
    @Query("SELECT COUNT(*) FROM users WHERE email = ?0 ALLOW FILTERING")
    Long countByEmail(String email);

    /**
     * Vérifie si un email existe (version optimisée)
     */
    default boolean existsByEmail(String email) {
        return countByEmail(email) > 0;
    }

    /**
     * Trouve un utilisateur par téléphone
     */
    @Query("SELECT * FROM users WHERE phone = ?0 ALLOW FILTERING")
    Optional<User> findByPhone(String phone);

    /**
     * Vérifie si un téléphone existe déjà
     */
    @Query("SELECT COUNT(*) FROM users WHERE phone = ?0 ALLOW FILTERING")
    Long countByPhone(String phone);

    /**
     * Vérifie si un téléphone existe
     */
    default boolean existsByPhone(String phone) {
        return countByPhone(phone) > 0;
    }

    /**
     * Trouve les utilisateurs par organisation
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 ALLOW FILTERING")
    List<User> findByOrganizationId(UUID organizationId);

    /**
     * Trouve les utilisateurs par type
     */
    @Query("SELECT * FROM users WHERE user_type = ?0 ALLOW FILTERING")
    List<User> findByUserType(UserType userType);

    /**
     * Trouve les utilisateurs par statut
     */
    @Query("SELECT * FROM users WHERE status = ?0 ALLOW FILTERING")
    List<User> findByStatus(UserStatus status);

    /**
     * Trouve les propriétaires d'organisation (OWNER)
     */
    @Query("SELECT * FROM users WHERE user_type = 'OWNER' ALLOW FILTERING")
    List<User> findAllOwners();

    /**
     * Trouve les clients (CLIENT)
     */
    @Query("SELECT * FROM users WHERE user_type = 'CLIENT' ALLOW FILTERING")
    List<User> findAllClients();

    /**
     * Trouve les utilisateurs actifs
     */
    @Query("SELECT * FROM users WHERE status = 'ACTIVE' ALLOW FILTERING")
    List<User> findActiveUsers();

    /**
     * Trouve un utilisateur par token de vérification email
     */
    @Query("SELECT * FROM users WHERE email_verification_token = ?0 ALLOW FILTERING")
    Optional<User> findByEmailVerificationToken(String token);

    /**
     * Trouve un utilisateur par token de reset password
     */
    @Query("SELECT * FROM users WHERE password_reset_token = ?0 ALLOW FILTERING")
    Optional<User> findByPasswordResetToken(String token);

    /**
     * Trouve les utilisateurs créés entre deux dates
     */
    @Query("SELECT * FROM users WHERE created_at >= ?0 AND created_at <= ?1 ALLOW FILTERING")
    List<User> findByCreatedAtBetween(LocalDateTime startDate, LocalDateTime endDate);

    /**
     * Trouve les utilisateurs avec des tentatives de connexion échouées
     */
    @Query("SELECT * FROM users WHERE failed_login_attempts > 0 ALLOW FILTERING")
    List<User> findUsersWithFailedLoginAttempts();

    /**
     * Trouve les utilisateurs verrouillés
     */
    @Query("SELECT * FROM users WHERE locked_until > ?0 ALLOW FILTERING")
    List<User> findLockedUsers(LocalDateTime now);

    /**
     * Trouve les utilisateurs avec email non vérifié
     */
    @Query("SELECT * FROM users WHERE email_verified = false ALLOW FILTERING")
    List<User> findUsersWithUnverifiedEmail();

    /**
     * Trouve les utilisateurs avec téléphone non vérifié
     */
    @Query("SELECT * FROM users WHERE phone_verified = false ALLOW FILTERING")
    List<User> findUsersWithUnverifiedPhone();

    /**
     * Trouve les utilisateurs par organisation et type
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 AND user_type = ?1 ALLOW FILTERING")
    List<User> findByOrganizationIdAndUserType(UUID organizationId, UserType userType);

    /**
     * Trouve les propriétaires par organisation (normalement un seul)
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 AND user_type = 'OWNER' ALLOW FILTERING")
    List<User> findOwnersByOrganizationId(UUID organizationId);

    /**
     * Trouve le personnel d'une organisation
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 AND user_type = 'STAFF' ALLOW FILTERING")
    List<User> findStaffByOrganizationId(UUID organizationId);

    /**
     * Trouve les utilisateurs connectés récemment
     */
    @Query("SELECT * FROM users WHERE last_login_at >= ?0 ALLOW FILTERING")
    List<User> findRecentlyLoggedInUsers(LocalDateTime since);

    /**
     * Compte les utilisateurs par type
     */
    @Query("SELECT COUNT(*) FROM users WHERE user_type = ?0 ALLOW FILTERING")
    Long countByUserType(UserType userType);

    /**
     * Compte les utilisateurs par statut
     */
    @Query("SELECT COUNT(*) FROM users WHERE status = ?0 ALLOW FILTERING")
    Long countByStatus(UserStatus status);

    /**
     * Compte les utilisateurs par organisation
     */
    @Query("SELECT COUNT(*) FROM users WHERE organization_id = ?0 ALLOW FILTERING")
    Long countByOrganizationId(UUID organizationId);

    /**
     * Trouve les utilisateurs créés aujourd'hui
     */
    @Query("SELECT * FROM users WHERE created_at >= ?0 ALLOW FILTERING")
    List<User> findCreatedSince(LocalDateTime since);

    /**
     * Trouve les super administrateurs
     */
    @Query("SELECT * FROM users WHERE user_type = 'SUPER_ADMIN' ALLOW FILTERING")
    List<User> findSuperAdmins();
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\user\service\AuthService.java ---

```java
package inc.yowyob.rental_api.user.service;

import inc.yowyob.rental_api.config.AppProperties;
import inc.yowyob.rental_api.core.enums.UserStatus;
import inc.yowyob.rental_api.security.jwt.JwtTokenProvider;
import inc.yowyob.rental_api.user.dto.*;
import inc.yowyob.rental_api.user.entities.User;
import inc.yowyob.rental_api.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider jwtTokenProvider;
    private final AuthenticationManager authenticationManager;
    private final AppProperties appProperties;

    /**
     * Authentifie un utilisateur
     */
    @Transactional
    public AuthResponseDto login(LoginRequestDto loginRequest, String ipAddress) {
        log.info("Login attempt for email: {}", loginRequest.getEmail());

        // Récupérer l'utilisateur
        User user = userRepository.findByEmail(loginRequest.getEmail())
            .orElseThrow(() -> new BadCredentialsException("Invalid email or password"));

        // Vérifier si le compte est verrouillé
        if (user.isLocked()) {
            log.warn("Login attempt for locked account: {}", loginRequest.getEmail());
            throw new DisabledException("Account is temporarily locked due to failed login attempts");
        }

        // Vérifier si l'utilisateur peut se connecter
        if (!user.canLogin()) {
            log.warn("Login attempt for inactive account: {}", loginRequest.getEmail());
            throw new DisabledException("Account is not active");
        }

        try {
            // Authentifier
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                    loginRequest.getEmail(),
                    loginRequest.getPassword()
                )
            );

            // Mettre à jour les informations de connexion
            user.updateLastLogin(ipAddress);
            userRepository.save(user);

            // Générer les tokens
            String accessToken = jwtTokenProvider.generateToken(user);
            String refreshToken = jwtTokenProvider.generateRefreshToken(user);

            log.info("Successful login for user: {}", user.getEmail());

            return buildAuthResponse(user, accessToken, refreshToken);

        } catch (BadCredentialsException e) {
            // Incrémenter les tentatives échouées
            user.incrementFailedLoginAttempts();
            userRepository.save(user);

            log.warn("Failed login attempt for email: {} (attempts: {})",
                loginRequest.getEmail(), user.getFailedLoginAttempts());

            throw new BadCredentialsException("Invalid email or password");
        }
    }

    /**
     * Enregistre un nouvel utilisateur
     */
    @Transactional
    public AuthResponseDto register(RegisterRequestDto registerRequest) {
        log.info("Registration attempt for email: {}", registerRequest.getEmail());

        // Vérifier si l'email existe déjà
        if (userRepository.existsByEmail(registerRequest.getEmail())) {
            throw new IllegalArgumentException("Email is already registered");
        }

        // Créer l'utilisateur
        User user = new User(
            registerRequest.getEmail(),
            passwordEncoder.encode(registerRequest.getPassword()),
            registerRequest.getFirstName(),
            registerRequest.getLastName(),
            registerRequest.getUserType()
        );

        user.setPhone(registerRequest.getPhone());

        // Activer directement pour les clients, en attente pour les propriétaires
        if (registerRequest.getUserType().getCode().equals("client")) {
            user.setStatus(UserStatus.ACTIVE);
        }

        User savedUser = userRepository.save(user);

        // Générer les tokens
        String accessToken = jwtTokenProvider.generateToken(savedUser);
        String refreshToken = jwtTokenProvider.generateRefreshToken(savedUser);

        log.info("Successful registration for user: {}", savedUser.getEmail());

        return buildAuthResponse(savedUser, accessToken, refreshToken);
    }

    /**
     * Rafraîchit le token d'accès
     */
    public AuthResponseDto refreshToken(String refreshToken) {
        log.debug("Refresh token request");

        if (!jwtTokenProvider.validateToken(refreshToken)) {
            throw new BadCredentialsException("Invalid refresh token");
        }

        UUID userId = jwtTokenProvider.getUserIdFromToken(refreshToken);
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new BadCredentialsException("User not found"));

        if (!user.canLogin()) {
            throw new DisabledException("Account is not active");
        }

        // Générer de nouveaux tokens
        String newAccessToken = jwtTokenProvider.generateToken(user);
        String newRefreshToken = jwtTokenProvider.generateRefreshToken(user);

        log.debug("Token refreshed for user: {}", user.getEmail());

        return buildAuthResponse(user, newAccessToken, newRefreshToken);
    }

    /**
     * Change le mot de passe d'un utilisateur
     */
    @Transactional
    public void changePassword(UUID userId, String currentPassword, String newPassword) {
        log.info("Password change request for user: {}", userId);

        User user = userRepository.findById(userId)
            .orElseThrow(() -> new IllegalArgumentException("User not found"));

        // Vérifier le mot de passe actuel
        if (!passwordEncoder.matches(currentPassword, user.getPassword())) {
            throw new BadCredentialsException("Current password is incorrect");
        }

        // Mettre à jour le mot de passe
        user.setPassword(passwordEncoder.encode(newPassword));
        user.setUpdatedAt(java.time.LocalDateTime.now());
        userRepository.save(user);

        log.info("Password changed successfully for user: {}", userId);
    }

    /**
     * Construit la réponse d'authentification
     */
    private AuthResponseDto buildAuthResponse(User user, String accessToken, String refreshToken) {
        return AuthResponseDto.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .tokenType("Bearer")
            .expiresIn(appProperties.getJwt().getExpiration() / 1000) // en secondes
            .userId(user.getId())
            .email(user.getEmail())
            .firstName(user.getFirstName())
            .lastName(user.getLastName())
            .userType(user.getUserType().getCode())
            .status(user.getStatus().getCode())
            .organizationId(user.getOrganizationId())
            .emailVerified(user.getEmailVerified())
            .phoneVerified(user.getPhoneVerified())
            .lastLoginAt(user.getLastLoginAt())
            .build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api\vehicle\readme.md ---

```markdown

```

--- PATH: src\main\resources\application.properties ---

```properties
# ================================================================
# APPLICATION INFORMATION
# ================================================================
spring.application.name=rental-api

# ================================================================
# SERVER CONFIGURATION
# ================================================================
server.port=8080
server.servlet.context-path=/api/v1
server.error.include-message=always
server.error.include-binding-errors=always

# ================================================================
# SCYLLA CONFIGURATION
# ================================================================
#spring.cassandra.contact-points=35.243.210.150
#spring.cassandra.keyspace-name=rental
#spring.cassandra.username=scylla
#spring.cassandra.password=kqcUjdvn4AI2z1E
#spring.cassandra.port=9042
#spring.cassandra.local-datacenter=GCE_US_EAST_1

spring.cassandra.contact-points=localhost
spring.cassandra.keyspace-name=rental
# spring.cassandra.username=cassandra
# spring.cassandra.password=cassandra
spring.cassandra.port=9042
spring.cassandra.local-datacenter=datacenter1

spring.cassandra.schema-action=CREATE_IF_NOT_EXISTS
spring.cassandra.request.timeout=10s
spring.cassandra.connection.connect-timeout=10s
spring.cassandra.connection.init-query-timeout=10s

# ================================================================
# CORS CONFIGURATION
# ================================================================
app.cors.allowed-origins=http://localhost:3000,http://localhost:8080,http://localhost:4200
app.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,PATCH
app.cors.allowed-headers=*
app.cors.allow-credentials=true

# ================================================================
# SECURITY & JWT CONFIGURATION
# ================================================================
app.jwt.secret=KsBman55FbHOoyT2SCZl46RZnc0oySFlenms644lQPKOt//JW78D5brRZuWelLzVts/ACnJcdXtIEl3D57KO5w==
app.jwt.expiration=86400000
app.jwt.refresh-expiration=604800000

# ================================================================
# OPENAPI / SWAGGER CONFIGURATION
# ================================================================
springdoc.api-docs.enabled=true
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operations-sorter=method
springdoc.swagger-ui.tags-sorter=alpha
springdoc.swagger-ui.display-request-duration=true
springdoc.swagger-ui.show-extensions=true
springdoc.swagger-ui.show-common-extensions=true

# Configuration des groupes d'API
#springdoc.group-configs[0].group=public
#springdoc.group-configs[0].paths-to-match=/api/v1/auth/**, /api/v1/onboarding/**
#springdoc.group-configs[1].group=admin
#springdoc.group-configs[1].paths-to-match=/api/v1/admin/**
#springdoc.group-configs[2].group=business
#springdoc.group-configs[2].paths-to-match=/api/v1/organizations/**, /api/v1/vehicles/**, /api/v1/rentals/**

# ================================================================
# FILE UPLOAD CONFIGURATION
# ================================================================
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
app.file.upload-dir=./uploads
app.file.max-file-size=10485760
app.file.allowed-extensions=jpg,jpeg,png,pdf,doc,docx
```

--- PATH: src\test\java\inc\yowyob\rental_api\RentalApiApplicationTests.java ---

```java
package inc.yowyob.rental_api;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class RentalApiApplicationTests {

	@Test
	void contextLoads() {
	}

}
```
